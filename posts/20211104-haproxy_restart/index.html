<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>Haproxy的Zero downtime重启如何做 | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content='Nginx 可以用 kill -HUP 来重启，不会丢失已建连接。Haproxy 如何做才能做到 zero downtime 无缝重载呢？
做法如下：
一、配置
编译harpoxy的时候带上参数 USE_SYSTEMD，选择 Haproxy 1.8 以上版本
make TARGET=linux2628 USE_GETADDRINFO=1 USE_ZLIB=1 USE_REGPARM=1 USE_OPENSSL=1 \
  USE_SYSTEMD=1 USE_PCRE=1 USE_PCRE_JIT=1 USE_NS=1
make install
Haproxy无缝重载技术：


旧进程当前管理的连接根据 file descriptor 文件描述符通过 socket 套接字传输到新进程。


在这个过程中，文件socket（unix socket）的连接没有断开。


新进程在充当 master-worker 主工作者的同时执行此任务。


综上所述，通过使用unix socket来维护连接状态并在旧进程和新进程之间传递，防止了连接丢失。
haproxy 的运行使用 Systemd 重载，使用 -Ws 方式。 （此外，在构建时必须启用 USE_SYSTEMD）
  -D : start as a daemon. The process detaches from the current terminal after
    forking, and errors are not reported anymore in the terminal. It is
    equivalent to the "daemon" keyword in the "global" section of the
    configuration. It is recommended to always force it in any init script so
    that a faulty configuration doesn&#39;t prevent the system from booting.

  -W : master-worker mode. It is equivalent to the "master-worker" keyword in
    the "global" section of the configuration. This mode will launch a "master"
    which will monitor the "workers". Using this mode, you can reload HAProxy
    directly by sending a SIGUSR2 signal to the master.  The master-worker mode
    is compatible either with the foreground or daemon mode.  It is
    recommended to use this mode with multiprocess and systemd.

  -Ws : master-worker mode with support of `notify` type of systemd service.
    This option is only available when HAProxy was built with `USE_SYSTEMD`
    build option enabled.
具体的启动脚本：/etc/systemd/system/haproxy.service'><meta name=author content><link rel=canonical href=https://rendoumi.com/posts/20211104-haproxy_restart/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.74dff769c849e7908342c626b27d92486e2c568e0a3c69bddd21ad6aad6674d3.css integrity="sha256-dN/3achJ55CDQsYmsn2SSG4sVo4KPGm93SGtaq1mdNM=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/20211104-haproxy_restart/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/20211104-haproxy_restart/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="Haproxy的Zero downtime重启如何做"><meta property="og:description" content='Nginx 可以用 kill -HUP 来重启，不会丢失已建连接。Haproxy 如何做才能做到 zero downtime 无缝重载呢？
做法如下：
一、配置 编译harpoxy的时候带上参数 USE_SYSTEMD，选择 Haproxy 1.8 以上版本
make TARGET=linux2628 USE_GETADDRINFO=1 USE_ZLIB=1 USE_REGPARM=1 USE_OPENSSL=1 \ USE_SYSTEMD=1 USE_PCRE=1 USE_PCRE_JIT=1 USE_NS=1 make install Haproxy无缝重载技术：
旧进程当前管理的连接根据 file descriptor 文件描述符通过 socket 套接字传输到新进程。
在这个过程中，文件socket（unix socket）的连接没有断开。
新进程在充当 master-worker 主工作者的同时执行此任务。
综上所述，通过使用unix socket来维护连接状态并在旧进程和新进程之间传递，防止了连接丢失。
haproxy 的运行使用 Systemd 重载，使用 -Ws 方式。 （此外，在构建时必须启用 USE_SYSTEMD）
-D : start as a daemon. The process detaches from the current terminal after forking, and errors are not reported anymore in the terminal. It is equivalent to the "daemon" keyword in the "global" section of the configuration. It is recommended to always force it in any init script so that a faulty configuration doesn&#39;t prevent the system from booting. -W : master-worker mode. It is equivalent to the "master-worker" keyword in the "global" section of the configuration. This mode will launch a "master" which will monitor the "workers". Using this mode, you can reload HAProxy directly by sending a SIGUSR2 signal to the master. The master-worker mode is compatible either with the foreground or daemon mode. It is recommended to use this mode with multiprocess and systemd. -Ws : master-worker mode with support of `notify` type of systemd service. This option is only available when HAProxy was built with `USE_SYSTEMD` build option enabled. 具体的启动脚本：/etc/systemd/system/haproxy.service'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-04T10:30:11+08:00"><meta property="article:modified_time" content="2021-11-04T10:30:11+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Haproxy的Zero downtime重启如何做"><meta name=twitter:description content='Nginx 可以用 kill -HUP 来重启，不会丢失已建连接。Haproxy 如何做才能做到 zero downtime 无缝重载呢？
做法如下：
一、配置
编译harpoxy的时候带上参数 USE_SYSTEMD，选择 Haproxy 1.8 以上版本
make TARGET=linux2628 USE_GETADDRINFO=1 USE_ZLIB=1 USE_REGPARM=1 USE_OPENSSL=1 \
  USE_SYSTEMD=1 USE_PCRE=1 USE_PCRE_JIT=1 USE_NS=1
make install
Haproxy无缝重载技术：


旧进程当前管理的连接根据 file descriptor 文件描述符通过 socket 套接字传输到新进程。


在这个过程中，文件socket（unix socket）的连接没有断开。


新进程在充当 master-worker 主工作者的同时执行此任务。


综上所述，通过使用unix socket来维护连接状态并在旧进程和新进程之间传递，防止了连接丢失。
haproxy 的运行使用 Systemd 重载，使用 -Ws 方式。 （此外，在构建时必须启用 USE_SYSTEMD）
  -D : start as a daemon. The process detaches from the current terminal after
    forking, and errors are not reported anymore in the terminal. It is
    equivalent to the "daemon" keyword in the "global" section of the
    configuration. It is recommended to always force it in any init script so
    that a faulty configuration doesn&#39;t prevent the system from booting.

  -W : master-worker mode. It is equivalent to the "master-worker" keyword in
    the "global" section of the configuration. This mode will launch a "master"
    which will monitor the "workers". Using this mode, you can reload HAProxy
    directly by sending a SIGUSR2 signal to the master.  The master-worker mode
    is compatible either with the foreground or daemon mode.  It is
    recommended to use this mode with multiprocess and systemd.

  -Ws : master-worker mode with support of `notify` type of systemd service.
    This option is only available when HAProxy was built with `USE_SYSTEMD`
    build option enabled.
具体的启动脚本：/etc/systemd/system/haproxy.service'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"},{"@type":"ListItem","position":2,"name":"Haproxy的Zero downtime重启如何做","item":"https://rendoumi.com/posts/20211104-haproxy_restart/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Haproxy的Zero downtime重启如何做","name":"Haproxy的Zero downtime重启如何做","description":"Nginx 可以用 kill -HUP 来重启，不会丢失已建连接。Haproxy 如何做才能做到 zero downtime 无缝重载呢？\n做法如下：\n一、配置 编译harpoxy的时候带上参数 USE_SYSTEMD，选择 Haproxy 1.8 以上版本\nmake TARGET=linux2628 USE_GETADDRINFO=1 USE_ZLIB=1 USE_REGPARM=1 USE_OPENSSL=1 \\ USE_SYSTEMD=1 USE_PCRE=1 USE_PCRE_JIT=1 USE_NS=1 make install Haproxy无缝重载技术：\n旧进程当前管理的连接根据 file descriptor 文件描述符通过 socket 套接字传输到新进程。\n在这个过程中，文件socket（unix socket）的连接没有断开。\n新进程在充当 master-worker 主工作者的同时执行此任务。\n综上所述，通过使用unix socket来维护连接状态并在旧进程和新进程之间传递，防止了连接丢失。\nhaproxy 的运行使用 Systemd 重载，使用 -Ws 方式。 （此外，在构建时必须启用 USE_SYSTEMD）\n-D : start as a daemon. The process detaches from the current terminal after forking, and errors are not reported anymore in the terminal. It is equivalent to the \u0026#34;daemon\u0026#34; keyword in the \u0026#34;global\u0026#34; section of the configuration. It is recommended to always force it in any init script so that a faulty configuration doesn\u0026#39;t prevent the system from booting. -W : master-worker mode. It is equivalent to the \u0026#34;master-worker\u0026#34; keyword in the \u0026#34;global\u0026#34; section of the configuration. This mode will launch a \u0026#34;master\u0026#34; which will monitor the \u0026#34;workers\u0026#34;. Using this mode, you can reload HAProxy directly by sending a SIGUSR2 signal to the master. The master-worker mode is compatible either with the foreground or daemon mode. It is recommended to use this mode with multiprocess and systemd. -Ws : master-worker mode with support of `notify` type of systemd service. This option is only available when HAProxy was built with `USE_SYSTEMD` build option enabled. 具体的启动脚本：/etc/systemd/system/haproxy.service\n","keywords":[],"articleBody":"Nginx 可以用 kill -HUP 来重启，不会丢失已建连接。Haproxy 如何做才能做到 zero downtime 无缝重载呢？\n做法如下：\n一、配置 编译harpoxy的时候带上参数 USE_SYSTEMD，选择 Haproxy 1.8 以上版本\nmake TARGET=linux2628 USE_GETADDRINFO=1 USE_ZLIB=1 USE_REGPARM=1 USE_OPENSSL=1 \\ USE_SYSTEMD=1 USE_PCRE=1 USE_PCRE_JIT=1 USE_NS=1 make install Haproxy无缝重载技术：\n旧进程当前管理的连接根据 file descriptor 文件描述符通过 socket 套接字传输到新进程。\n在这个过程中，文件socket（unix socket）的连接没有断开。\n新进程在充当 master-worker 主工作者的同时执行此任务。\n综上所述，通过使用unix socket来维护连接状态并在旧进程和新进程之间传递，防止了连接丢失。\nhaproxy 的运行使用 Systemd 重载，使用 -Ws 方式。 （此外，在构建时必须启用 USE_SYSTEMD）\n-D : start as a daemon. The process detaches from the current terminal after forking, and errors are not reported anymore in the terminal. It is equivalent to the \"daemon\" keyword in the \"global\" section of the configuration. It is recommended to always force it in any init script so that a faulty configuration doesn't prevent the system from booting. -W : master-worker mode. It is equivalent to the \"master-worker\" keyword in the \"global\" section of the configuration. This mode will launch a \"master\" which will monitor the \"workers\". Using this mode, you can reload HAProxy directly by sending a SIGUSR2 signal to the master. The master-worker mode is compatible either with the foreground or daemon mode. It is recommended to use this mode with multiprocess and systemd. -Ws : master-worker mode with support of `notify` type of systemd service. This option is only available when HAProxy was built with `USE_SYSTEMD` build option enabled. 具体的启动脚本：/etc/systemd/system/haproxy.service\n[Unit] Description=HAProxy Load Balancer After=network-online.target Wants=network-online.target [Service] Environment=\"CONFIG=/etc/haproxy/haproxy.cfg\" \"PIDFILE=/run/haproxy.pid\" ExecStartPre=/usr/sbin/haproxy -f $CONFIG -c -q ExecStart=/usr/sbin/haproxy -Ws -f $CONFIG -p $PIDFILE ExecReload=/usr/sbin/haproxy -f $CONFIG -c -q ExecReload=/bin/kill -USR2 $MAINPID KillMode=mixed Restart=always SuccessExitStatus=143 Type=notify # The following lines leverage SystemD's sandboxing options to provide # defense in depth protection at the expense of restricting some flexibility # in your setup (e.g. placement of your configuration files) or possibly # reduced performance. See systemd.service(5) and systemd.exec(5) for further # information. # NoNewPrivileges=true # ProtectHome=true # If you want to use 'ProtectSystem=strict' you should whitelist the PIDFILE, # any state files and any other files written using 'ReadWritePaths' or # 'RuntimeDirectory'. # ProtectSystem=true # ProtectKernelTunables=true # ProtectKernelModules=true # ProtectControlGroups=true # If your SystemD version supports them, you can add: @reboot, @swap, @sync # SystemCallFilter=~@cpu-emulation @keyring @module @obsolete @raw-io [Install] WantedBy=multi-user.target 二、验证 验证是否真的是无缝重载的步骤如下：\n在haproxy.cfg的global段落中加入stat的配置：\nstats socket /var/run/haproxy.sock level admin expose-fd listeners process 1 运行一个不断循环重启的脚本：\nwhile true ; do systemctl reload haproxy ; sleep 3 ; done 用 apache 的压测工具 ab 来压一下。\nSend request while service is reloading:\nab -r -c 20 -n 100000 http://127.0.0.1/ 最后检查结果中 “Failed requests” 是否为零就可以了\n","wordCount":"389","inLanguage":"zh","datePublished":"2021-11-04T10:30:11+08:00","dateModified":"2021-11-04T10:30:11+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://rendoumi.com/posts/20211104-haproxy_restart/"},"publisher":{"@type":"Organization","name":"八戒的技术博客","logo":{"@type":"ImageObject","url":"https://rendoumi.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="八戒的技术博客 (Alt + H)">八戒的技术博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Haproxy的Zero downtime重启如何做
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2021-11-04 10:30:11 +0800 CST'>2021年11月4日</span></div></header><div class=post-content><p>Nginx 可以用 kill -HUP 来重启，不会丢失已建连接。Haproxy 如何做才能做到 zero downtime 无缝重载呢？</p><p>做法如下：</p><h2 id=一配置>一、配置<a hidden class=anchor aria-hidden=true href=#一配置>#</a></h2><p>编译harpoxy的时候带上参数 USE_SYSTEMD，选择 Haproxy 1.8 以上版本</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>make <span class=nv>TARGET</span><span class=o>=</span>linux2628 <span class=nv>USE_GETADDRINFO</span><span class=o>=</span><span class=m>1</span> <span class=nv>USE_ZLIB</span><span class=o>=</span><span class=m>1</span> <span class=nv>USE_REGPARM</span><span class=o>=</span><span class=m>1</span> <span class=nv>USE_OPENSSL</span><span class=o>=</span><span class=m>1</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=nv>USE_SYSTEMD</span><span class=o>=</span><span class=m>1</span> <span class=nv>USE_PCRE</span><span class=o>=</span><span class=m>1</span> <span class=nv>USE_PCRE_JIT</span><span class=o>=</span><span class=m>1</span> <span class=nv>USE_NS</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>make install
</span></span></code></pre></div><p>Haproxy无缝重载技术：</p><ul><li><p>旧进程当前管理的连接根据 file descriptor 文件描述符通过 socket 套接字传输到新进程。</p></li><li><p>在这个过程中，文件socket（unix socket）的连接没有断开。</p></li><li><p>新进程在充当 master-worker 主工作者的同时执行此任务。</p></li></ul><p>综上所述，通过使用unix socket来维护连接状态并在旧进程和新进程之间传递，防止了连接丢失。</p><p>haproxy 的运行使用 Systemd 重载，使用 -Ws 方式。 （此外，在构建时必须启用 USE_SYSTEMD）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl>  <span class=na>-D : start as a daemon. The process detaches from the current terminal after</span>
</span></span><span class=line><span class=cl>    <span class=na>forking, and errors are not reported anymore in the terminal. It is</span>
</span></span><span class=line><span class=cl>    <span class=na>equivalent to the &#34;daemon&#34; keyword in the &#34;global&#34; section of the</span>
</span></span><span class=line><span class=cl>    <span class=na>configuration. It is recommended to always force it in any init script so</span>
</span></span><span class=line><span class=cl>    <span class=na>that a faulty configuration doesn&#39;t prevent the system from booting.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=na>-W : master-worker mode. It is equivalent to the &#34;master-worker&#34; keyword in</span>
</span></span><span class=line><span class=cl>    <span class=na>the &#34;global&#34; section of the configuration. This mode will launch a &#34;master&#34;</span>
</span></span><span class=line><span class=cl>    <span class=na>which will monitor the &#34;workers&#34;. Using this mode, you can reload HAProxy</span>
</span></span><span class=line><span class=cl>    <span class=na>directly by sending a SIGUSR2 signal to the master.  The master-worker mode</span>
</span></span><span class=line><span class=cl>    <span class=na>is compatible either with the foreground or daemon mode.  It is</span>
</span></span><span class=line><span class=cl>    <span class=na>recommended to use this mode with multiprocess and systemd.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=na>-Ws : master-worker mode with support of `notify` type of systemd service.</span>
</span></span><span class=line><span class=cl>    <span class=na>This option is only available when HAProxy was built with `USE_SYSTEMD`</span>
</span></span><span class=line><span class=cl>    <span class=na>build option enabled.</span>
</span></span></code></pre></div><p>具体的启动脚本：/etc/systemd/system/haproxy.service</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>HAProxy Load Balancer</span>
</span></span><span class=line><span class=cl><span class=na>After</span><span class=o>=</span><span class=s>network-online.target</span>
</span></span><span class=line><span class=cl><span class=na>Wants</span><span class=o>=</span><span class=s>network-online.target</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=na>Environment</span><span class=o>=</span><span class=s>&#34;CONFIG=/etc/haproxy/haproxy.cfg&#34; &#34;PIDFILE=/run/haproxy.pid&#34;</span>
</span></span><span class=line><span class=cl><span class=na>ExecStartPre</span><span class=o>=</span><span class=s>/usr/sbin/haproxy -f $CONFIG -c -q</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/usr/sbin/haproxy -Ws -f $CONFIG -p $PIDFILE</span>
</span></span><span class=line><span class=cl><span class=na>ExecReload</span><span class=o>=</span><span class=s>/usr/sbin/haproxy -f $CONFIG -c -q</span>
</span></span><span class=line><span class=cl><span class=na>ExecReload</span><span class=o>=</span><span class=s>/bin/kill -USR2 $MAINPID</span>
</span></span><span class=line><span class=cl><span class=na>KillMode</span><span class=o>=</span><span class=s>mixed</span>
</span></span><span class=line><span class=cl><span class=na>Restart</span><span class=o>=</span><span class=s>always</span>
</span></span><span class=line><span class=cl><span class=na>SuccessExitStatus</span><span class=o>=</span><span class=s>143</span>
</span></span><span class=line><span class=cl><span class=na>Type</span><span class=o>=</span><span class=s>notify</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># The following lines leverage SystemD&#39;s sandboxing options to provide</span>
</span></span><span class=line><span class=cl><span class=c1># defense in depth protection at the expense of restricting some flexibility</span>
</span></span><span class=line><span class=cl><span class=c1># in your setup (e.g. placement of your configuration files) or possibly</span>
</span></span><span class=line><span class=cl><span class=c1># reduced performance. See systemd.service(5) and systemd.exec(5) for further</span>
</span></span><span class=line><span class=cl><span class=c1># information.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># NoNewPrivileges=true</span>
</span></span><span class=line><span class=cl><span class=c1># ProtectHome=true</span>
</span></span><span class=line><span class=cl><span class=c1># If you want to use &#39;ProtectSystem=strict&#39; you should whitelist the PIDFILE,</span>
</span></span><span class=line><span class=cl><span class=c1># any state files and any other files written using &#39;ReadWritePaths&#39; or</span>
</span></span><span class=line><span class=cl><span class=c1># &#39;RuntimeDirectory&#39;.</span>
</span></span><span class=line><span class=cl><span class=c1># ProtectSystem=true</span>
</span></span><span class=line><span class=cl><span class=c1># ProtectKernelTunables=true</span>
</span></span><span class=line><span class=cl><span class=c1># ProtectKernelModules=true</span>
</span></span><span class=line><span class=cl><span class=c1># ProtectControlGroups=true</span>
</span></span><span class=line><span class=cl><span class=c1># If your SystemD version supports them, you can add: @reboot, @swap, @sync</span>
</span></span><span class=line><span class=cl><span class=c1># SystemCallFilter=~@cpu-emulation @keyring @module @obsolete @raw-io</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</span></span></code></pre></div><h2 id=二验证>二、验证<a hidden class=anchor aria-hidden=true href=#二验证>#</a></h2><p>验证是否真的是无缝重载的步骤如下：</p><p>在haproxy.cfg的global段落中加入stat的配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=na>stats socket /var/run/haproxy.sock level admin expose-fd listeners process 1</span>
</span></span></code></pre></div><p>运行一个不断循环重启的脚本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>while</span> <span class=nb>true</span> <span class=p>;</span> <span class=k>do</span> systemctl reload haproxy <span class=p>;</span> sleep <span class=m>3</span> <span class=p>;</span> <span class=k>done</span>
</span></span></code></pre></div><p>用 apache 的压测工具 ab 来压一下。</p><p>Send request while service is reloading:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ab -r -c <span class=m>20</span> -n <span class=m>100000</span> http://127.0.0.1/
</span></span></code></pre></div><p>最后检查结果中 &ldquo;Failed requests&rdquo; 是否为零就可以了</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>