<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>Javascripts之数组的reduce | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content="研究一下 javascripts 的 reduce ，reduce 是既能改变 array 的 size，又能改变数值的函数，filter 是只能改变size，不能改变数值；而 map 是不能改变 size，可以改变数值。很拗口吧，三个兄弟。
简单介绍一下 reduce。
假设我们有一个数组:
[1, 2, 3, 4]
我们要对整个数组求和.
reduce 实际是按照下列的算式来进行求和的:
((((1) + 2) + 3) + 4)
那实际 reduce 函数执行中，你可以按你需求来自定义你自己的 + 操作符。数组的值也可以是其他的任意东西。听起来有点意思吧？
1、 Reduce 是干嘛的
在一个函数式编程语言中，reduce 其实有很多别的名称，比如 fold（对折）, accumulate（累加器）, aggregate（聚合器）, compress（压缩） 甚至叫 inject（注入）。
2、 Reduce 的参数
常用用法如下：
let myArray      = [/* 首先定义一个数组 */];
let callbackfn   = /* 再定义一个函数 */ ;
let initialvalue = /* 任意一个初始化的值 */ ;

myArray.reduce(callbackfn)
myArray.reduce(callbackfn, initialValue)
reduce 的参数如下:
callbackfn: 必须是一个函数，会在整个数组中反复调用，reduce 调用 callbackfn 的时候有4个参数，我们定义它们是 previousValue, currentElement, index 和 array ，看起来像下面一样:"><meta name=author content="八戒"><link rel=canonical href=https://rendoumi.com/posts/20220520-javascripts_reduce/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5d8a858b4ad07d913988e10d3c3dbc8c171f45316a396de8a60d67f44840812d.css integrity="sha256-XYqFi0rQfZE5iOENPD28jBcfRTFqOW3opg1n9EhAgS0=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/20220520-javascripts_reduce/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/20220520-javascripts_reduce/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="Javascripts之数组的reduce"><meta property="og:description" content="研究一下 javascripts 的 reduce ，reduce 是既能改变 array 的 size，又能改变数值的函数，filter 是只能改变size，不能改变数值；而 map 是不能改变 size，可以改变数值。很拗口吧，三个兄弟。
简单介绍一下 reduce。
假设我们有一个数组:
[1, 2, 3, 4] 我们要对整个数组求和.
reduce 实际是按照下列的算式来进行求和的:
((((1) + 2) + 3) + 4)
那实际 reduce 函数执行中，你可以按你需求来自定义你自己的 + 操作符。数组的值也可以是其他的任意东西。听起来有点意思吧？
1、 Reduce 是干嘛的 在一个函数式编程语言中，reduce 其实有很多别的名称，比如 fold（对折）, accumulate（累加器）, aggregate（聚合器）, compress（压缩） 甚至叫 inject（注入）。
2、 Reduce 的参数 常用用法如下：
let myArray = [/* 首先定义一个数组 */]; let callbackfn = /* 再定义一个函数 */ ; let initialvalue = /* 任意一个初始化的值 */ ; myArray.reduce(callbackfn) myArray.reduce(callbackfn, initialValue) reduce 的参数如下:
callbackfn: 必须是一个函数，会在整个数组中反复调用，reduce 调用 callbackfn 的时候有4个参数，我们定义它们是 previousValue, currentElement, index 和 array ，看起来像下面一样:"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-20T09:30:11+08:00"><meta property="article:modified_time" content="2022-05-20T09:30:11+08:00"><meta property="og:image" content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Javascripts之数组的reduce"><meta name=twitter:description content="研究一下 javascripts 的 reduce ，reduce 是既能改变 array 的 size，又能改变数值的函数，filter 是只能改变size，不能改变数值；而 map 是不能改变 size，可以改变数值。很拗口吧，三个兄弟。
简单介绍一下 reduce。
假设我们有一个数组:
[1, 2, 3, 4]
我们要对整个数组求和.
reduce 实际是按照下列的算式来进行求和的:
((((1) + 2) + 3) + 4)
那实际 reduce 函数执行中，你可以按你需求来自定义你自己的 + 操作符。数组的值也可以是其他的任意东西。听起来有点意思吧？
1、 Reduce 是干嘛的
在一个函数式编程语言中，reduce 其实有很多别的名称，比如 fold（对折）, accumulate（累加器）, aggregate（聚合器）, compress（压缩） 甚至叫 inject（注入）。
2、 Reduce 的参数
常用用法如下：
let myArray      = [/* 首先定义一个数组 */];
let callbackfn   = /* 再定义一个函数 */ ;
let initialvalue = /* 任意一个初始化的值 */ ;

myArray.reduce(callbackfn)
myArray.reduce(callbackfn, initialValue)
reduce 的参数如下:
callbackfn: 必须是一个函数，会在整个数组中反复调用，reduce 调用 callbackfn 的时候有4个参数，我们定义它们是 previousValue, currentElement, index 和 array ，看起来像下面一样:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"},{"@type":"ListItem","position":2,"name":"Javascripts之数组的reduce","item":"https://rendoumi.com/posts/20220520-javascripts_reduce/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Javascripts之数组的reduce","name":"Javascripts之数组的reduce","description":"研究一下 javascripts 的 reduce ，reduce 是既能改变 array 的 size，又能改变数值的函数，filter 是只能改变size，不能改变数值；而 map 是不能改变 size，可以改变数值。很拗口吧，三个兄弟。\n简单介绍一下 reduce。\n假设我们有一个数组:\n[1, 2, 3, 4] 我们要对整个数组求和.\nreduce 实际是按照下列的算式来进行求和的:\n((((1) + 2) + 3) + 4)\n那实际 reduce 函数执行中，你可以按你需求来自定义你自己的 + 操作符。数组的值也可以是其他的任意东西。听起来有点意思吧？\n1、 Reduce 是干嘛的 在一个函数式编程语言中，reduce 其实有很多别的名称，比如 fold（对折）, accumulate（累加器）, aggregate（聚合器）, compress（压缩） 甚至叫 inject（注入）。\n2、 Reduce 的参数 常用用法如下：\nlet myArray = [/* 首先定义一个数组 */]; let callbackfn = /* 再定义一个函数 */ ; let initialvalue = /* 任意一个初始化的值 */ ; myArray.reduce(callbackfn) myArray.reduce(callbackfn, initialValue) reduce 的参数如下:\ncallbackfn: 必须是一个函数，会在整个数组中反复调用，reduce 调用 callbackfn 的时候有4个参数，我们定义它们是 previousValue, currentElement, index 和 array ，看起来像下面一样:\n","keywords":[],"articleBody":"研究一下 javascripts 的 reduce ，reduce 是既能改变 array 的 size，又能改变数值的函数，filter 是只能改变size，不能改变数值；而 map 是不能改变 size，可以改变数值。很拗口吧，三个兄弟。\n简单介绍一下 reduce。\n假设我们有一个数组:\n[1, 2, 3, 4] 我们要对整个数组求和.\nreduce 实际是按照下列的算式来进行求和的:\n((((1) + 2) + 3) + 4)\n那实际 reduce 函数执行中，你可以按你需求来自定义你自己的 + 操作符。数组的值也可以是其他的任意东西。听起来有点意思吧？\n1、 Reduce 是干嘛的 在一个函数式编程语言中，reduce 其实有很多别的名称，比如 fold（对折）, accumulate（累加器）, aggregate（聚合器）, compress（压缩） 甚至叫 inject（注入）。\n2、 Reduce 的参数 常用用法如下：\nlet myArray = [/* 首先定义一个数组 */]; let callbackfn = /* 再定义一个函数 */ ; let initialvalue = /* 任意一个初始化的值 */ ; myArray.reduce(callbackfn) myArray.reduce(callbackfn, initialValue) reduce 的参数如下:\ncallbackfn: 必须是一个函数，会在整个数组中反复调用，reduce 调用 callbackfn 的时候有4个参数，我们定义它们是 previousValue, currentElement, index 和 array ，看起来像下面一样:\ncallbackfn(previousValue, currentElement, index, array) 解释一下:\npreviousValue: 这个参数就是一个累加器。 currentElement: 数组中处理的当前元素。 index: 当前元素的索引值。 array: myArray调用的数组. Return value（返回值）: 最后一次调用 callbackfn 的时候，返回值就是整个 reduce 过程的返回值。如果不是最后一次调用，它返回的值会被下次的 callbackFn 的 previousvalue 参数接收。\n我们必须注意，函数就是函数，函数过程中处理的变量要么是外围的 scope 带进来的，要么是函数体内自定义的，所以后面两个 index 和 array 也是必须存在的，只不过是 reduce 函数替你自动处理了。\n3、 用画图来理解 Reduce 看上面的图，reduce 和 reductRight 函数的区别就是方向，一个是从左到右，一个是从右到左。\n关注点如下:\nacc 相当于 previousValue ，累加器. curVal 相当于currentElement，当前处理元素. 数组中的每个元素向下输出到圈 r 就是curVal输出到***r***的具体表现. 包含数组元素的长方形输出到下一个 r 就是 acc 输出到***r***的具体表现. 初始化值在数组外单独表示，它是作为一个单独的 acc 输出到 r 中的. 3、 用流程图来理解 Reduce 下面用20行的伪代码来详细解释整个 reduce 的过程，首先进入 reduce 函数：\nIf initialValue is present, 如果初始化变量不为空 If myArray has no elements, 接着判断如果数组为空 Return initialValue. 那么直接初始化变量作为 reduce 的结果返回 else 初始化变量为空但数组不为空 Let accumulator be initialValue. 把初始变量赋给累加器 If the method is reduce, 如果方法是 reduce Let startIndex be the index of the leftmost element of myArray. 把数组最左边的元素的index值赋予 startIndex else 如果初始化变量为空 If myArray has no elements, 如果数组没有元素 Throw TypeError. 初始化变量为空，数组也为空，直接抛类型错误 Else if myArray has just only one element, 如果数组只有一个元素 Return that element. 那么直接将数组中唯一一个元素作为 reduce 结果返回 Else If the method is reduce,如果方法是 reduce Let accumulator be the leftmost element of myArray. 把数组最左边的第一个元素赋给累加器 If the method is reduce, 如果方法是reduce In left to right order, for each element of myArray such that its index i ≥ startingIndex, 按照从左到右的顺序，遍历数组中的每一个元素，来个大循环 Set accumulator to callbackfn(accumulator, myArray[i], i, myArray). 数组中的每个元素，都逐个设置到callbackfn函数中并运行 Return accumulator. 累加器的值作为 reduce 结果返回 仔细理解，搞完了吧。\n给个实际例子，一群学生，有男有女，先选出女学生，然后计算出她们每个人的平均成绩，最后把她们打印出来：\nconst students = [ { name: \"Anna\", sex: \"f\", grades: [4.5, 3.5, 4] }, { name: \"Dennis\", sex: \"m\", country: \"Germany\", grades: [5, 1.5, 4] }, { name: \"Martha\", sex: \"f\", grades: [5, 4, 2.5, 3] }, { name: \"Brock\", sex: \"m\", grades: [4, 3, 2] } ]; //TODO: Compute and Return female students results using functional programming. function studentResult(students){ return students.filter(x =\u003e x.sex==\"f\").reduce((init,cur)=\u003e{ cur['grades']=cur.grades.reduce((acc,cur) =\u003e acc+cur,0)/cur.grades.length; return init.concat(cur); },[]); } console.log(studentResult(students)); //[ { name: 'Anna', sex: 'f', grades: 4 }, { name: 'Martha', sex: 'f', grades: 3.625 } ] 注意一点，reduce 可以动 size，也可以动值，上面实际改变了 students 数组元素的值了，不太好。应该赋一个新值 concat 或者 push 进新数组。\n下面的方法就没有动原数组的数据：\nfunction studentResult(students){ return students.filter(x =\u003e x.sex==\"f\").reduce((init,cur)=\u003e{ let newarr = {}; newarr['name']=cur.name; newarr['sex']=cur.sex; newarr['grades']=cur.grades.reduce((acc,cur) =\u003e acc+cur,0)/cur.grades.length; init.push(newarr); return init; },[]); } ","wordCount":"398","inLanguage":"zh","image":"https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-05-20T09:30:11+08:00","dateModified":"2022-05-20T09:30:11+08:00","author":{"@type":"Person","name":"八戒"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rendoumi.com/posts/20220520-javascripts_reduce/"},"publisher":{"@type":"Organization","name":"八戒的技术博客","logo":{"@type":"ImageObject","url":"https://rendoumi.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="Home (Alt + H)"><img src=https://rendoumi.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rendoumi.com/>主页</a>&nbsp;»&nbsp;<a href=https://rendoumi.com/posts/>所有文章</a></div><h1 class="post-title entry-hint-parent">Javascripts之数组的reduce
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2022-05-20 09:30:11 +0800 CST'>2022年20月</span>&nbsp;·&nbsp;<span>2 分钟</span>&nbsp;·&nbsp;<span>398 字</span>&nbsp;·&nbsp;<span>八戒</span></div></header><div class=post-content><p>研究一下 javascripts 的 reduce ，reduce 是既能改变 array 的 size，又能改变数值的函数，filter 是只能改变size，不能改变数值；而 map 是不能改变 size，可以改变数值。很拗口吧，三个兄弟。</p><p>简单介绍一下 reduce。</p><p>假设我们有一个数组:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span></code></pre></div><p>我们要对整个数组求和.</p><p><code>reduce</code> 实际是按照下列的算式来进行求和的:</p><p>((((1) + 2) + 3) + 4)</p><p>那实际 <code>reduce</code> 函数执行中，你可以按你需求来自定义你自己的 + 操作符。数组的值也可以是其他的任意东西。听起来有点意思吧？</p><h4 id=1-reduce-是干嘛的><strong>1、</strong> Reduce 是干嘛的<a hidden class=anchor aria-hidden=true href=#1-reduce-是干嘛的>#</a></h4><p>在一个函数式编程语言中，reduce 其实有很多别的名称，比如 <strong>fold（对折）</strong>, <strong>accumulate（累加器）</strong>, <strong>aggregate（聚合器）</strong>, <strong>compress（压缩）</strong> 甚至叫 <strong>inject（注入）</strong>。</p><h4 id=2-reduce-的参数><strong>2、</strong> Reduce 的参数<a hidden class=anchor aria-hidden=true href=#2-reduce-的参数>#</a></h4><p>常用用法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>let</span> <span class=nv>myArray</span>      <span class=o>=</span> <span class=o>[</span>/* 首先定义一个数组 */<span class=o>]</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>let</span> <span class=nv>callbackfn</span>   <span class=o>=</span> /* 再定义一个函数 */ <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>let</span> <span class=nv>initialvalue</span> <span class=o>=</span> /* 任意一个初始化的值 */ <span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>myArray.reduce<span class=o>(</span>callbackfn<span class=o>)</span>
</span></span><span class=line><span class=cl>myArray.reduce<span class=o>(</span>callbackfn, initialValue<span class=o>)</span>
</span></span></code></pre></div><p><code>reduce</code> 的参数如下:</p><p><strong><code>callbackfn</code></strong>: 必须是一个函数，会在整个数组中反复调用，reduce 调用 callbackfn 的时候有4个参数，我们定义它们是 <code>previousValue</code>, <code>currentElement</code>, <code>index</code> 和 <code>array</code> ，看起来像下面一样:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>callbackfn</span><span class=p>(</span><span class=nx>previousValue</span><span class=p>,</span> <span class=nx>currentElement</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>array</span><span class=p>)</span>
</span></span></code></pre></div><p>解释一下:</p><ol><li><code>previousValue</code>: 这个参数就是一个累加器。</li><li><code>currentElement</code>: 数组中处理的当前元素。</li><li><code>index</code>: 当前元素的索引值。</li><li><code>array</code>: <code>myArray</code>调用的数组.</li></ol><p><strong>Return value（返回值）</strong>: 最后一次调用 <code>callbackfn</code> 的时候，返回值就是整个 reduce 过程的返回值。如果不是最后一次调用，它返回的值会被下次的 <code>callbackFn</code> 的 <code>previousvalue</code> 参数接收。</p><p>我们必须注意，函数就是函数，函数过程中处理的变量要么是外围的 scope 带进来的，要么是函数体内自定义的，所以后面两个 index 和 array 也是必须存在的，只不过是 reduce 函数替你自动处理了。</p><h4 id=3-用画图来理解-reduce><strong>3、</strong> 用画图来理解 Reduce<a hidden class=anchor aria-hidden=true href=#3-用画图来理解-reduce>#</a></h4><p><img alt=image-20220521150951876 loading=lazy src=/posts/20220520-javascripts_reduce/image-20220521150951876.png></p><p>看上面的图，reduce 和 reductRight 函数的区别就是方向，一个是从左到右，一个是从右到左。</p><p>关注点如下:</p><ul><li><code>acc</code> 相当于 <code>previousValue</code> ，累加器.</li><li><code>curVal</code> 相当于<code>currentElement</code>，当前处理元素.</li><li>数组中的每个元素向下输出到圈 <em><strong><code>r</code></strong></em> 就是<code>curVal</code>输出到***<code>r</code>***的具体表现.</li><li>包含数组元素的长方形输出到下一个 <em><strong><code>r</code></strong></em> 就是 <code>acc</code> 输出到***<code>r</code>***的具体表现.</li><li>初始化值在数组外单独表示，它是作为一个单独的 <code>acc</code> 输出到 <em><strong><code>r</code></strong></em> 中的.</li></ul><h4 id=3-用流程图来理解-reduce><strong>3、</strong> 用流程图来理解 Reduce<a hidden class=anchor aria-hidden=true href=#3-用流程图来理解-reduce>#</a></h4><p>下面用20行的伪代码来详细解释整个 reduce 的过程，首先进入 reduce 函数：</p><ol><li>If <code>initialValue</code> is present, 如果初始化变量不为空</li><li>　　　If <code>myArray</code> has no elements, 接着判断如果数组为空</li><li>　　　　　　Return <code>initialValue</code>. 那么直接初始化变量作为 reduce 的结果返回</li><li>　　else 初始化变量为空但数组不为空</li><li>　　　　Let <code>accumulator</code> be <code>initialValue</code>. 把初始变量赋给累加器</li><li>　　　　If the method is <code>reduce</code>, 如果方法是 reduce</li><li>　　　　　　Let <code>startIndex</code> be the index of the leftmost element of <code>myArray</code>. 把数组最左边的元素的index值赋予 startIndex</li><li>else 如果初始化变量为空</li><li>　　If <code>myArray</code> has no elements, 如果数组没有元素</li><li>　　　　Throw <code>TypeError</code>. 初始化变量为空，数组也为空，直接抛类型错误</li><li>　　Else if <code>myArray</code> has just only one element, 如果数组只有一个元素</li><li>　　　　Return that element. 那么直接将数组中唯一一个元素作为 reduce 结果返回</li><li>　　Else</li><li>　　　　If the method is <code>reduce</code>,如果方法是 reduce</li><li>　　　　　　Let <code>accumulator</code> be the leftmost element of <code>myArray</code>. 把数组最左边的第一个元素赋给累加器</li><li></li><li>If the method is <code>reduce</code>, 如果方法是reduce</li><li>　　In left to right order, for each element of <code>myArray</code> such that its index <code>i</code> ≥ <code>startingIndex</code>, 按照从左到右的顺序，遍历数组中的每一个元素，来个大循环</li><li>　　　　Set <code>accumulator</code> to <code>callbackfn(accumulator, myArray[i], i, myArray)</code>. 数组中的每个元素，都逐个设置到callbackfn函数中并运行</li><li>Return <code>accumulator</code>. 累加器的值作为 reduce 结果返回</li></ol><p>仔细理解，搞完了吧。</p><p>给个实际例子，一群学生，有男有女，先选出女学生，然后计算出她们每个人的平均成绩，最后把她们打印出来：</p><pre tabindex=0><code class=language-javascripts data-lang=javascripts>const students = [ 
  { 
    name: &#34;Anna&#34;, 
    sex: &#34;f&#34;, 
    grades: [4.5, 3.5, 4] 
  }, 

  { 
    name: &#34;Dennis&#34;, 
    sex: &#34;m&#34;, 
    country: &#34;Germany&#34;, 
    grades: [5, 1.5, 4] 
  }, 

  { 
    name: &#34;Martha&#34;, 
    sex: &#34;f&#34;, 
    grades: [5, 4, 2.5, 3] 
  }, 

  { 
    name: &#34;Brock&#34;, 
    sex: &#34;m&#34;, 
    grades: [4, 3, 2] 
  } 
]; 

   
//TODO: Compute and Return female students results using functional programming. 

function studentResult(students){ 
  return students.filter(x =&gt; x.sex==&#34;f&#34;).reduce((init,cur)=&gt;{ 
    cur[&#39;grades&#39;]=cur.grades.reduce((acc,cur) =&gt; acc+cur,0)/cur.grades.length; 
    return init.concat(cur);
  },[]); 
} 

console.log(studentResult(students));
//[ { name: &#39;Anna&#39;, sex: &#39;f&#39;, grades: 4 },   { name: &#39;Martha&#39;, sex: &#39;f&#39;, grades: 3.625 } ] 
</code></pre><p>注意一点，reduce 可以动 size，也可以动值，上面实际改变了 students 数组元素的值了，不太好。应该赋一个新值 concat 或者 push 进新数组。</p><p>下面的方法就没有动原数组的数据：</p><pre tabindex=0><code class=language-javascripts data-lang=javascripts>function studentResult(students){ 
  return students.filter(x =&gt; x.sex==&#34;f&#34;).reduce((init,cur)=&gt;{ 
    let newarr = {}; 
    newarr[&#39;name&#39;]=cur.name; 
    newarr[&#39;sex&#39;]=cur.sex; 
    newarr[&#39;grades&#39;]=cur.grades.reduce((acc,cur) =&gt; acc+cur,0)/cur.grades.length; 
    init.push(newarr); 
    return init; 
  },[]); 
} 
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://rendoumi.com/posts/20220521-javascripts_module/><span class=title>« 上一页</span><br><span>javascripts中的module</span>
</a><a class=next href=https://rendoumi.com/posts/20220401-docker_mini_image/><span class=title>下一页 »</span><br><span>面试之Docker如何打出最小的镜像</span></a></nav></footer><div id=comments></div><script src=https://cwd.js.org/cwd.js></script><script>const comments=new CWDComments({el:"#comments",apiBaseUrl:"https://cwd.rendoumi.qzz.io"});comments.mount()</script></article></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>