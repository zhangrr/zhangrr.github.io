<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇 | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content='新托管了一个机房服务器，基本全用开源软件来构建：
那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用
结构图如下，证书是放在了Nginx ingres上：

那方法有很多，各有利弊，说下第二个，Caddy的做法
Caddy真的是王道，什么泛域名，一个端口跑3个协议，都可以
用到Caddy，就要解决后端Nginx ingress无法获得客户真实IP的问题
Caddy配置如下：
General Settings：
Enable Layer4 Proxy 要勾选上
Auto HTTPS 要选中Off

其它保持默认，然后去到Layer4 Proxy进行配置，同样要配2个，一个HTTP，一个TLS

编辑HTTP的代理，注意 Domain 的地方需要把用到的所有域名列进去

编译TLS的代理

注意上面，Proxy Protocol都要选中v2，这样客户端真实IP才可以透传给后端的Nginx ingress
那同样后端的Nginx ingress的configmap，也需要加上Proxy Protocol的部分

我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中
configmap ingress-nginx-controller，内容如下
apiVersion: v1
data:
  use-proxy-protocol: "true"
kind: ConfigMap
metadata:
  annotations:
    meta.helm.sh/release-name: ingress-nginx
    meta.helm.sh/release-namespace: ingress-nginx
    nginx.ingress.kubernetes.io/configuration-snippet: "true"
    nginx.ingress.kubernetes.io/location-snippet: "true"
    nginx.ingress.kubernetes.io/server-snippet: "true"
  creationTimestamp: "2025-08-27T07:38:49Z"
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.13.1
    helm.sh/chart: ingress-nginx-4.13.1
  name: ingress-nginx-controller
  namespace: ingress-nginx
  resourceVersion: "22298827"
  uid: d6eeef3c-7e44-4667-854a-c7693006b221
编辑后，nginx ingress会自动reload'><meta name=author content="八戒"><link rel=canonical href=https://rendoumi.com/posts/20251014-opnsense_caddy/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5d8a858b4ad07d913988e10d3c3dbc8c171f45316a396de8a60d67f44840812d.css integrity="sha256-XYqFi0rQfZE5iOENPD28jBcfRTFqOW3opg1n9EhAgS0=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/20251014-opnsense_caddy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/20251014-opnsense_caddy/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇"><meta property="og:description" content='新托管了一个机房服务器，基本全用开源软件来构建：
那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用
结构图如下，证书是放在了Nginx ingres上：
那方法有很多，各有利弊，说下第二个，Caddy的做法
Caddy真的是王道，什么泛域名，一个端口跑3个协议，都可以
用到Caddy，就要解决后端Nginx ingress无法获得客户真实IP的问题
Caddy配置如下：
General Settings：
Enable Layer4 Proxy 要勾选上
Auto HTTPS 要选中Off
其它保持默认，然后去到Layer4 Proxy进行配置，同样要配2个，一个HTTP，一个TLS
编辑HTTP的代理，注意 Domain 的地方需要把用到的所有域名列进去
编译TLS的代理
注意上面，Proxy Protocol都要选中v2，这样客户端真实IP才可以透传给后端的Nginx ingress
那同样后端的Nginx ingress的configmap，也需要加上Proxy Protocol的部分
我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中
configmap ingress-nginx-controller，内容如下
apiVersion: v1 data: use-proxy-protocol: "true" kind: ConfigMap metadata: annotations: meta.helm.sh/release-name: ingress-nginx meta.helm.sh/release-namespace: ingress-nginx nginx.ingress.kubernetes.io/configuration-snippet: "true" nginx.ingress.kubernetes.io/location-snippet: "true" nginx.ingress.kubernetes.io/server-snippet: "true" creationTimestamp: "2025-08-27T07:38:49Z" labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.13.1 helm.sh/chart: ingress-nginx-4.13.1 name: ingress-nginx-controller namespace: ingress-nginx resourceVersion: "22298827" uid: d6eeef3c-7e44-4667-854a-c7693006b221 编辑后，nginx ingress会自动reload'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-14T09:05:11+08:00"><meta property="article:modified_time" content="2025-10-14T09:05:11+08:00"><meta property="og:image" content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇"><meta name=twitter:description content='新托管了一个机房服务器，基本全用开源软件来构建：
那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用
结构图如下，证书是放在了Nginx ingres上：

那方法有很多，各有利弊，说下第二个，Caddy的做法
Caddy真的是王道，什么泛域名，一个端口跑3个协议，都可以
用到Caddy，就要解决后端Nginx ingress无法获得客户真实IP的问题
Caddy配置如下：
General Settings：
Enable Layer4 Proxy 要勾选上
Auto HTTPS 要选中Off

其它保持默认，然后去到Layer4 Proxy进行配置，同样要配2个，一个HTTP，一个TLS

编辑HTTP的代理，注意 Domain 的地方需要把用到的所有域名列进去

编译TLS的代理

注意上面，Proxy Protocol都要选中v2，这样客户端真实IP才可以透传给后端的Nginx ingress
那同样后端的Nginx ingress的configmap，也需要加上Proxy Protocol的部分

我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中
configmap ingress-nginx-controller，内容如下
apiVersion: v1
data:
  use-proxy-protocol: "true"
kind: ConfigMap
metadata:
  annotations:
    meta.helm.sh/release-name: ingress-nginx
    meta.helm.sh/release-namespace: ingress-nginx
    nginx.ingress.kubernetes.io/configuration-snippet: "true"
    nginx.ingress.kubernetes.io/location-snippet: "true"
    nginx.ingress.kubernetes.io/server-snippet: "true"
  creationTimestamp: "2025-08-27T07:38:49Z"
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.13.1
    helm.sh/chart: ingress-nginx-4.13.1
  name: ingress-nginx-controller
  namespace: ingress-nginx
  resourceVersion: "22298827"
  uid: d6eeef3c-7e44-4667-854a-c7693006b221
编辑后，nginx ingress会自动reload'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"},{"@type":"ListItem","position":2,"name":"OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇","item":"https://rendoumi.com/posts/20251014-opnsense_caddy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇","name":"OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇","description":"新托管了一个机房服务器，基本全用开源软件来构建：\n那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用\n结构图如下，证书是放在了Nginx ingres上：\n那方法有很多，各有利弊，说下第二个，Caddy的做法\nCaddy真的是王道，什么泛域名，一个端口跑3个协议，都可以\n用到Caddy，就要解决后端Nginx ingress无法获得客户真实IP的问题\nCaddy配置如下：\nGeneral Settings：\nEnable Layer4 Proxy 要勾选上\nAuto HTTPS 要选中Off\n其它保持默认，然后去到Layer4 Proxy进行配置，同样要配2个，一个HTTP，一个TLS\n编辑HTTP的代理，注意 Domain 的地方需要把用到的所有域名列进去\n编译TLS的代理\n注意上面，Proxy Protocol都要选中v2，这样客户端真实IP才可以透传给后端的Nginx ingress\n那同样后端的Nginx ingress的configmap，也需要加上Proxy Protocol的部分\n我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中\nconfigmap ingress-nginx-controller，内容如下\napiVersion: v1 data: use-proxy-protocol: \u0026#34;true\u0026#34; kind: ConfigMap metadata: annotations: meta.helm.sh/release-name: ingress-nginx meta.helm.sh/release-namespace: ingress-nginx nginx.ingress.kubernetes.io/configuration-snippet: \u0026#34;true\u0026#34; nginx.ingress.kubernetes.io/location-snippet: \u0026#34;true\u0026#34; nginx.ingress.kubernetes.io/server-snippet: \u0026#34;true\u0026#34; creationTimestamp: \u0026#34;2025-08-27T07:38:49Z\u0026#34; labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.13.1 helm.sh/chart: ingress-nginx-4.13.1 name: ingress-nginx-controller namespace: ingress-nginx resourceVersion: \u0026#34;22298827\u0026#34; uid: d6eeef3c-7e44-4667-854a-c7693006b221 编辑后，nginx ingress会自动reload\n","keywords":[],"articleBody":"新托管了一个机房服务器，基本全用开源软件来构建：\n那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用\n结构图如下，证书是放在了Nginx ingres上：\n那方法有很多，各有利弊，说下第二个，Caddy的做法\nCaddy真的是王道，什么泛域名，一个端口跑3个协议，都可以\n用到Caddy，就要解决后端Nginx ingress无法获得客户真实IP的问题\nCaddy配置如下：\nGeneral Settings：\nEnable Layer4 Proxy 要勾选上\nAuto HTTPS 要选中Off\n其它保持默认，然后去到Layer4 Proxy进行配置，同样要配2个，一个HTTP，一个TLS\n编辑HTTP的代理，注意 Domain 的地方需要把用到的所有域名列进去\n编译TLS的代理\n注意上面，Proxy Protocol都要选中v2，这样客户端真实IP才可以透传给后端的Nginx ingress\n那同样后端的Nginx ingress的configmap，也需要加上Proxy Protocol的部分\n我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中\nconfigmap ingress-nginx-controller，内容如下\napiVersion: v1 data: use-proxy-protocol: \"true\" kind: ConfigMap metadata: annotations: meta.helm.sh/release-name: ingress-nginx meta.helm.sh/release-namespace: ingress-nginx nginx.ingress.kubernetes.io/configuration-snippet: \"true\" nginx.ingress.kubernetes.io/location-snippet: \"true\" nginx.ingress.kubernetes.io/server-snippet: \"true\" creationTimestamp: \"2025-08-27T07:38:49Z\" labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.13.1 helm.sh/chart: ingress-nginx-4.13.1 name: ingress-nginx-controller namespace: ingress-nginx resourceVersion: \"22298827\" uid: d6eeef3c-7e44-4667-854a-c7693006b221 编辑后，nginx ingress会自动reload\n然后去OPNsense Caddy的General Settings，配置生效\n这样就很完美了，后端的Nginx ingress也可以获得真实客户端IP了，看看nginx的log确认一下。\n注意：relayd和caddy不能同时启动。\n","wordCount":"88","inLanguage":"zh","image":"https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-10-14T09:05:11+08:00","dateModified":"2025-10-14T09:05:11+08:00","author":{"@type":"Person","name":"八戒"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rendoumi.com/posts/20251014-opnsense_caddy/"},"publisher":{"@type":"Organization","name":"八戒的技术博客","logo":{"@type":"ImageObject","url":"https://rendoumi.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="Home (Alt + H)"><img src=https://rendoumi.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rendoumi.com/>主页</a>&nbsp;»&nbsp;<a href=https://rendoumi.com/posts/>所有文章</a></div><h1 class="post-title entry-hint-parent">OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2025-10-14 09:05:11 +0800 CST'>2025年14月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>88 字</span>&nbsp;·&nbsp;<span>八戒</span></div></header><div class=post-content><p>新托管了一个机房服务器，基本全用开源软件来构建：</p><p>那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用</p><p>结构图如下，证书是放在了Nginx ingres上：</p><p><img alt=image-20251014091045980 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014091045980.png></p><p>那方法有很多，各有利弊，说下第二个，<code>Caddy</code>的做法</p><p>Caddy真的是王道，什么泛域名，一个端口跑3个协议，都可以</p><p>用到Caddy，就要解决后端Nginx ingress无法获得客户真实IP的问题</p><p>Caddy配置如下：</p><p>General Settings：</p><p>Enable Layer4 Proxy 要勾选上</p><p>Auto HTTPS 要选中Off</p><p><img alt=image-20251014094437866 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014094437866.png></p><p>其它保持默认，然后去到Layer4 Proxy进行配置，同样要配2个，一个HTTP，一个TLS</p><p><img alt=image-20251014094651852 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014094651852.png></p><p>编辑HTTP的代理，注意 Domain 的地方需要把用到的所有域名列进去</p><p><img alt=image-20251014094830397 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014094830397.png></p><p>编译TLS的代理</p><p><img alt=image-20251014095137803 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014095137803.png></p><p>注意上面，Proxy Protocol都要选中v2，这样客户端真实IP才可以透传给后端的Nginx ingress</p><p>那同样后端的Nginx ingress的configmap，也需要加上Proxy Protocol的部分</p><p><img alt=image-20251014095327561 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014095327561.png></p><p>我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中</p><p>configmap ingress-nginx-controller，内容如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>apiVersion: v1
</span></span><span class=line><span class=cl>data:
</span></span><span class=line><span class=cl>  use-proxy-protocol: <span class=s2>&#34;true&#34;</span>
</span></span><span class=line><span class=cl>kind: ConfigMap
</span></span><span class=line><span class=cl>metadata:
</span></span><span class=line><span class=cl>  annotations:
</span></span><span class=line><span class=cl>    meta.helm.sh/release-name: ingress-nginx
</span></span><span class=line><span class=cl>    meta.helm.sh/release-namespace: ingress-nginx
</span></span><span class=line><span class=cl>    nginx.ingress.kubernetes.io/configuration-snippet: <span class=s2>&#34;true&#34;</span>
</span></span><span class=line><span class=cl>    nginx.ingress.kubernetes.io/location-snippet: <span class=s2>&#34;true&#34;</span>
</span></span><span class=line><span class=cl>    nginx.ingress.kubernetes.io/server-snippet: <span class=s2>&#34;true&#34;</span>
</span></span><span class=line><span class=cl>  creationTimestamp: <span class=s2>&#34;2025-08-27T07:38:49Z&#34;</span>
</span></span><span class=line><span class=cl>  labels:
</span></span><span class=line><span class=cl>    app.kubernetes.io/component: controller
</span></span><span class=line><span class=cl>    app.kubernetes.io/instance: ingress-nginx
</span></span><span class=line><span class=cl>    app.kubernetes.io/managed-by: Helm
</span></span><span class=line><span class=cl>    app.kubernetes.io/name: ingress-nginx
</span></span><span class=line><span class=cl>    app.kubernetes.io/part-of: ingress-nginx
</span></span><span class=line><span class=cl>    app.kubernetes.io/version: 1.13.1
</span></span><span class=line><span class=cl>    helm.sh/chart: ingress-nginx-4.13.1
</span></span><span class=line><span class=cl>  name: ingress-nginx-controller
</span></span><span class=line><span class=cl>  namespace: ingress-nginx
</span></span><span class=line><span class=cl>  resourceVersion: <span class=s2>&#34;22298827&#34;</span>
</span></span><span class=line><span class=cl>  uid: d6eeef3c-7e44-4667-854a-c7693006b221
</span></span></code></pre></div><p>编辑后，nginx ingress会自动reload</p><p>然后去OPNsense Caddy的General Settings，配置生效</p><p><img alt=image-20251014095612776 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014095612776.png></p><p>这样就很完美了，后端的Nginx ingress也可以获得真实客户端IP了，看看nginx的log确认一下。</p><p><img alt=image-20251014095739437 loading=lazy src=/posts/20251014-opnsense_caddy/image-20251014095739437.png></p><p>注意：relayd和caddy不能同时启动。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://rendoumi.com/posts/20251014-opensense_nginx/><span class=title>« 上一页</span><br><span>OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- Nginx篇</span>
</a><a class=next href=https://rendoumi.com/posts/20251014-opnsense_relayd/><span class=title>下一页 »</span><br><span>OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- relayd篇</span></a></nav></footer><div id=comments></div><script src=https://cwd.js.org/cwd.js></script><script>const comments=new CWDComments({el:"#comments",apiBaseUrl:"https://cwd.rendoumi.qzz.io"});comments.mount()</script></article></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>