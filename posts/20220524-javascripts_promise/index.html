<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>javascripts中的promise | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content="一、基本概念
1. 异步
所谓 &#34; 异步 &ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。
比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。
相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。
2. 回调函数
javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 &#34; 回调 &ldquo;。
读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。
fs.readfile('/etc/passwd', function(err, data) {
  if(err) throw err;
  console.log(data);
});
上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。
==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。=="><meta name=author content><link rel=canonical href=https://rendoumi.com/posts/20220524-javascripts_promise/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5d8a858b4ad07d913988e10d3c3dbc8c171f45316a396de8a60d67f44840812d.css integrity="sha256-XYqFi0rQfZE5iOENPD28jBcfRTFqOW3opg1n9EhAgS0=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/20220524-javascripts_promise/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/20220524-javascripts_promise/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="javascripts中的promise"><meta property="og:description" content="一、基本概念
1. 异步
所谓 &#34; 异步 “，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。
比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。
相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。
2. 回调函数
javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 &#34; 回调 “。
读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。
fs.readfile('/etc/passwd', function(err, data) { if(err) throw err; console.log(data); }); 上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。
==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。=="><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-24T09:30:11+08:00"><meta property="article:modified_time" content="2022-05-24T09:30:11+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="javascripts中的promise"><meta name=twitter:description content="一、基本概念
1. 异步
所谓 &#34; 异步 &ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。
比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。
相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。
2. 回调函数
javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 &#34; 回调 &ldquo;。
读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。
fs.readfile('/etc/passwd', function(err, data) {
  if(err) throw err;
  console.log(data);
});
上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。
==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。=="><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"},{"@type":"ListItem","position":2,"name":"javascripts中的promise","item":"https://rendoumi.com/posts/20220524-javascripts_promise/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"javascripts中的promise","name":"javascripts中的promise","description":"一、基本概念\n1. 异步\n所谓 \u0026quot; 异步 \u0026ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。\n比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。\n相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。\n2. 回调函数\njavascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 \u0026quot; 回调 \u0026ldquo;。\n读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。\nfs.readfile(\u0026#39;/etc/passwd\u0026#39;, function(err, data) { if(err) throw err; console.log(data); }); 上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。\n==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。==\n","keywords":[],"articleBody":"一、基本概念\n1. 异步\n所谓 \" 异步 “，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。\n比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。\n相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。\n2. 回调函数\njavascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 \" 回调 “。\n读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。\nfs.readfile('/etc/passwd', function(err, data) { if(err) throw err; console.log(data); }); 上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。\n==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。==\n3. promise\n“想像一下你是个小孩，你妈妈 promise 承诺你下星期给你一部新手机”\n只有下周来临的时候，你才会知道你真的得到一部手机，或者是骗你玩的。\n这就是 promise. 一个 promise 有三种状态：\nPending: 待定，你不知道你是否能得到一部手机 Resolved: 妈妈很高兴，你得到一部手机 Rejected: 妈妈不高兴，你没有得到一部手机 状态图如下：\n语法很简单：\n// promise syntax look like this new Promise(function (resolve, reject) { ... } ); 再看一下上面问题的解决方法：\n首先确定 Mom 的状态是 unhappy，然后建立一个 Promise 来确定是否得到手机，最后用一个函数 askMom 来调用这个 Promise\nresolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作。\nreject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。\n但是请注意以下两点：\nresolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列； resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。 var isMomHappy = false; // Promise var willIGetNewPhone = new Promise( function (resolve, reject) { if (isMomHappy) { var phone = { brand: 'Samsung', color: 'black' }; resolve(phone); // resolved } else { var reason = new Error('mom is not happy'); reject(reason); // rejected } } ); var askMom = function () { willIGetNewPhone .then(function (fulfilled) { // yay, you got a new phone console.log(fulfilled); // output: { brand: 'Samsung', color: 'black' } }) .catch(function (error) { // oops, mom didn't buy it console.log(error.message); // output: 'mom is not happy' }); }; askMom(); 很有点意思吧。抽象了，那就实际点。\njavascripts 中的 fetch 函数就是基于Promise范式的，promise 的 resolves 绑在了 Response 上。Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：\nfetch(\"http://192.168.1.6/graph_image_hubot.php?action=view\u0026local_graph_id=13619\u0026rra_id=5\") .then(response =\u003e { if (response.ok) { return response.buffer(); } throw new Error('Network response was not ok.'); }) .then(buffer =\u003e { const formData = new FormData(); formData.append( 'media', buffer, {filename: 'bandwidth.png', contentType: 'image/png' } ); robot.wwork.sendImageMessage(owner, formData); }); 上面的程序实际上是从 cacti 服务器拿到一张流量图片，然后 fetch 的结果 anyway，response总是有东西的，都会是成功的，所以我们必须再用 response.ok 来判断，成功就继续得到 buffer 流，最终送到 hubot 中去。三个过程用 then 串了起来，每一步都成功才会进行下一步。\n这样写避免了回调地狱，看起来也比较舒服。\n那什么时候用 promise 呢，它是异步的，有大IO读写硬盘、读写网络的时候用，上面是读写网络。下面再来一个读写磁盘的：\nconst {promise: {readFile, writeFile}} = require('fs'); (async () =\u003e { let content = await readFile('./data.txt', 'utf8'); await writeFile('2.txt', content, 'utf8'); console.log('ok'); })(); 上面的语法是 ES7 的，它更尽了一步，首先声明一个匿名的函数是 async 异步的，然后用await来进行等待，将读和写两个大操作都放到 await 的一步操作中去，这样程序看起来就变成同步的一步步等待了。跟 ES6 的 promise 比起来，更进了一步。\n","wordCount":"365","inLanguage":"zh","datePublished":"2022-05-24T09:30:11+08:00","dateModified":"2022-05-24T09:30:11+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://rendoumi.com/posts/20220524-javascripts_promise/"},"publisher":{"@type":"Organization","name":"八戒的技术博客","logo":{"@type":"ImageObject","url":"https://rendoumi.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="八戒的技术博客 (Alt + H)">八戒的技术博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">javascripts中的promise
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2022-05-24 09:30:11 +0800 CST'>2022年5月24日</span></div></header><div class=post-content><p><strong>一、基本概念</strong></p><p><strong>1. 异步</strong></p><p>所谓 " 异步 &ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。</p><p>比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。</p><p>相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。</p><p><strong>2. 回调函数</strong></p><p>javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 " 回调 &ldquo;。</p><p>读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。</p><pre tabindex=0><code>fs.readfile(&#39;/etc/passwd&#39;, function(err, data) {
  if(err) throw err;
  console.log(data);
});
</code></pre><p>上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。</p><p>==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。==</p><p><strong>3. promise</strong></p><p>“想像一下你是个小孩，你妈妈 promise 承诺你下星期给你一部新手机”</p><p>只有下周来临的时候，你才会知道你真的得到一部手机，或者是骗你玩的。</p><p>这就是 <strong>promise</strong>. 一个 promise 有三种状态：</p><ol><li>Pending: 待定，你不知道你是否能得到一部手机</li><li>Resolved: 妈妈很高兴，你得到一部手机</li><li>Rejected: 妈妈不高兴，你没有得到一部手机</li></ol><p>状态图如下：</p><p><img alt=image-20220527222312367 loading=lazy src=/posts/20220524-javascripts_promise/image-20220527222312367.png></p><p>语法很简单：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// promise syntax look like this
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=p>);</span>
</span></span></code></pre></div><p>再看一下上面问题的解决方法：</p><p>首先确定 Mom 的状态是 unhappy，然后建立一个 Promise 来确定是否得到手机，最后用一个函数 askMom 来调用这个 Promise</p><p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作。</p><p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p><p>但是请注意以下两点：</p><ul><li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li><li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li></ul><pre tabindex=0><code class=language-javascripts data-lang=javascripts>var isMomHappy = false;

// Promise
var willIGetNewPhone = new Promise(
    function (resolve, reject) {
        if (isMomHappy) {
            var phone = {
                brand: &#39;Samsung&#39;,
                color: &#39;black&#39;
            };
            resolve(phone); // resolved
        } else {
            var reason = new Error(&#39;mom is not happy&#39;);
            reject(reason); // rejected
        }

    }
);

var askMom = function () {
    willIGetNewPhone
        .then(function (fulfilled) {
            // yay, you got a new phone
            console.log(fulfilled);
             // output: { brand: &#39;Samsung&#39;, color: &#39;black&#39; }
        })
        .catch(function (error) {
            // oops, mom didn&#39;t buy it
            console.log(error.message);
             // output: &#39;mom is not happy&#39;
        });
};

askMom();
</code></pre><p>很有点意思吧。抽象了，那就实际点。</p><p>javascripts 中的 fetch 函数就是基于Promise范式的，promise 的 resolves 绑在了 Response 上。Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl>    <span class=nx>fetch</span><span class=p>(</span><span class=s2>&#34;http://192.168.1.6/graph_image_hubot.php?action=view&amp;local_graph_id=13619&amp;rra_id=5&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=p>=&gt;</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nx>response</span><span class=p>.</span><span class=nx>ok</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=nx>response</span><span class=p>.</span><span class=nx>buffer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Network response was not ok.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>buffer</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kr>const</span> <span class=nx>formData</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>FormData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=nx>formData</span><span class=p>.</span><span class=nx>append</span><span class=p>(</span> <span class=s1>&#39;media&#39;</span><span class=p>,</span> <span class=nx>buffer</span><span class=p>,</span> <span class=p>{</span><span class=nx>filename</span><span class=o>:</span> <span class=s1>&#39;bandwidth.png&#39;</span><span class=p>,</span> <span class=nx>contentType</span><span class=o>:</span> <span class=s1>&#39;image/png&#39;</span> <span class=p>}</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nx>robot</span><span class=p>.</span><span class=nx>wwork</span><span class=p>.</span><span class=nx>sendImageMessage</span><span class=p>(</span><span class=nx>owner</span><span class=p>,</span> <span class=nx>formData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span></code></pre></div><p>上面的程序实际上是从 cacti 服务器拿到一张流量图片，然后 fetch 的结果 anyway，response总是有东西的，都会是成功的，所以我们必须再用 response.ok 来判断，成功就继续得到 buffer 流，最终送到 hubot 中去。三个过程用 then 串了起来，每一步都成功才会进行下一步。</p><p>这样写避免了回调地狱，看起来也比较舒服。</p><p>那什么时候用 promise 呢，它是异步的，有大IO读写硬盘、读写网络的时候用，上面是读写网络。下面再来一个读写磁盘的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span><span class=nx>promise</span><span class=o>:</span> <span class=p>{</span><span class=nx>readFile</span><span class=p>,</span> <span class=nx>writeFile</span><span class=p>}}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fs&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=kr>async</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>content</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>readFile</span><span class=p>(</span><span class=s1>&#39;./data.txt&#39;</span><span class=p>,</span> <span class=s1>&#39;utf8&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>await</span> <span class=nx>writeFile</span><span class=p>(</span><span class=s1>&#39;2.txt&#39;</span><span class=p>,</span> <span class=nx>content</span><span class=p>,</span> <span class=s1>&#39;utf8&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;ok&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})();</span>
</span></span></code></pre></div><p>上面的语法是 ES7 的，它更尽了一步，首先声明一个匿名的函数是 async 异步的，然后用await来进行等待，将读和写两个大操作都放到 await 的一步操作中去，这样程序看起来就变成同步的一步步等待了。跟 ES6 的 promise 比起来，更进了一步。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>