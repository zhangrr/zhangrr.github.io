<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>javascripts中的promise | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content="一、基本概念
1. 异步
所谓 &#34; 异步 &ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。
比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。
相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。
2. 回调函数
javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 &#34; 回调 &ldquo;。
读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。
fs.readfile('/etc/passwd', function(err, data) {
  if(err) throw err;
  console.log(data);
});
上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。
==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。=="><meta name=author content="八戒"><link rel=canonical href=https://rendoumi.com/posts/20220524-javascripts_promise/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5d8a858b4ad07d913988e10d3c3dbc8c171f45316a396de8a60d67f44840812d.css integrity="sha256-XYqFi0rQfZE5iOENPD28jBcfRTFqOW3opg1n9EhAgS0=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/20220524-javascripts_promise/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/20220524-javascripts_promise/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="javascripts中的promise"><meta property="og:description" content="一、基本概念
1. 异步
所谓 &#34; 异步 “，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。
比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。
相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。
2. 回调函数
javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 &#34; 回调 “。
读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。
fs.readfile('/etc/passwd', function(err, data) { if(err) throw err; console.log(data); }); 上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。
==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。=="><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-24T09:30:11+08:00"><meta property="article:modified_time" content="2022-05-24T09:30:11+08:00"><meta property="og:image" content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="javascripts中的promise"><meta name=twitter:description content="一、基本概念
1. 异步
所谓 &#34; 异步 &ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。
比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。
相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。
2. 回调函数
javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 &#34; 回调 &ldquo;。
读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。
fs.readfile('/etc/passwd', function(err, data) {
  if(err) throw err;
  console.log(data);
});
上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。
==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。=="><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"},{"@type":"ListItem","position":2,"name":"javascripts中的promise","item":"https://rendoumi.com/posts/20220524-javascripts_promise/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"javascripts中的promise","name":"javascripts中的promise","description":"一、基本概念\n1. 异步\n所谓 \u0026quot; 异步 \u0026ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。\n比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。\n相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。\n2. 回调函数\njavascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 \u0026quot; 回调 \u0026ldquo;。\n读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。\nfs.readfile(\u0026#39;/etc/passwd\u0026#39;, function(err, data) { if(err) throw err; console.log(data); }); 上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。\n==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。==\n","keywords":[],"articleBody":"一、基本概念\n1. 异步\n所谓 \" 异步 “，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。\n比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。\n相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。\n2. 回调函数\njavascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 \" 回调 “。\n读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。\nfs.readfile('/etc/passwd', function(err, data) { if(err) throw err; console.log(data); }); 上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。\n==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。==\n3. promise\n“想像一下你是个小孩，你妈妈 promise 承诺你下星期给你一部新手机”\n只有下周来临的时候，你才会知道你真的得到一部手机，或者是骗你玩的。\n这就是 promise. 一个 promise 有三种状态：\nPending: 待定，你不知道你是否能得到一部手机 Resolved: 妈妈很高兴，你得到一部手机 Rejected: 妈妈不高兴，你没有得到一部手机 状态图如下：\n语法很简单：\n// promise syntax look like this new Promise(function (resolve, reject) { ... } ); 再看一下上面问题的解决方法：\n首先确定 Mom 的状态是 unhappy，然后建立一个 Promise 来确定是否得到手机，最后用一个函数 askMom 来调用这个 Promise\nresolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作。\nreject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。\n但是请注意以下两点：\nresolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列； resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。 var isMomHappy = false; // Promise var willIGetNewPhone = new Promise( function (resolve, reject) { if (isMomHappy) { var phone = { brand: 'Samsung', color: 'black' }; resolve(phone); // resolved } else { var reason = new Error('mom is not happy'); reject(reason); // rejected } } ); var askMom = function () { willIGetNewPhone .then(function (fulfilled) { // yay, you got a new phone console.log(fulfilled); // output: { brand: 'Samsung', color: 'black' } }) .catch(function (error) { // oops, mom didn't buy it console.log(error.message); // output: 'mom is not happy' }); }; askMom(); 很有点意思吧。抽象了，那就实际点。\njavascripts 中的 fetch 函数就是基于Promise范式的，promise 的 resolves 绑在了 Response 上。Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：\nfetch(\"http://192.168.1.6/graph_image_hubot.php?action=view\u0026local_graph_id=13619\u0026rra_id=5\") .then(response =\u003e { if (response.ok) { return response.buffer(); } throw new Error('Network response was not ok.'); }) .then(buffer =\u003e { const formData = new FormData(); formData.append( 'media', buffer, {filename: 'bandwidth.png', contentType: 'image/png' } ); robot.wwork.sendImageMessage(owner, formData); }); 上面的程序实际上是从 cacti 服务器拿到一张流量图片，然后 fetch 的结果 anyway，response总是有东西的，都会是成功的，所以我们必须再用 response.ok 来判断，成功就继续得到 buffer 流，最终送到 hubot 中去。三个过程用 then 串了起来，每一步都成功才会进行下一步。\n这样写避免了回调地狱，看起来也比较舒服。\n那什么时候用 promise 呢，它是异步的，有大IO读写硬盘、读写网络的时候用，上面是读写网络。下面再来一个读写磁盘的：\nconst {promise: {readFile, writeFile}} = require('fs'); (async () =\u003e { let content = await readFile('./data.txt', 'utf8'); await writeFile('2.txt', content, 'utf8'); console.log('ok'); })(); 上面的语法是 ES7 的，它更尽了一步，首先声明一个匿名的函数是 async 异步的，然后用await来进行等待，将读和写两个大操作都放到 await 的一步操作中去，这样程序看起来就变成同步的一步步等待了。跟 ES6 的 promise 比起来，更进了一步。\n","wordCount":"365","inLanguage":"zh","image":"https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-05-24T09:30:11+08:00","dateModified":"2022-05-24T09:30:11+08:00","author":{"@type":"Person","name":"八戒"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rendoumi.com/posts/20220524-javascripts_promise/"},"publisher":{"@type":"Organization","name":"八戒的技术博客","logo":{"@type":"ImageObject","url":"https://rendoumi.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="Home (Alt + H)"><img src=https://rendoumi.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rendoumi.com/>主页</a>&nbsp;»&nbsp;<a href=https://rendoumi.com/posts/>所有文章</a></div><h1 class="post-title entry-hint-parent">javascripts中的promise
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2022-05-24 09:30:11 +0800 CST'>2022年24月</span>&nbsp;·&nbsp;<span>2 分钟</span>&nbsp;·&nbsp;<span>365 字</span>&nbsp;·&nbsp;<span>八戒</span></div></header><div class=post-content><p><strong>一、基本概念</strong></p><p><strong>1. 异步</strong></p><p>所谓 " 异步 &ldquo;，简单说就是一个任务分成两段， 先执行第一段， 然后转而执行其他任务去， 等做好了准备， 再回过头执行第二段。</p><p>比如， 有一个任务是读取文件进行处理， 任务的第一段是向操作系统发出请求， 要求读取文件。 然后， 程序执行其他任务， 等到操作系统返回文件，再接着执行任务的第二段（ 处理文件）。 这种不连续的执行， 就叫做异步。</p><p>相应地， 连续的执行就叫做同步。 由于是连续执行， 不能插入其他任务， 所以操作系统从硬盘读取文件的这段时间， 程序只能干等着什么也做不了。</p><p><strong>2. 回调函数</strong></p><p>javascript 语言对异步编程的实现， 就是回调函数。 所谓回调函数， 就是把任务的第二段单独写在一个函数里面， 等到准备好了，继续执行的时候， 就直接调用这个函数。 它的英语名字 callback， 直译过来就是 " 回调 &ldquo;。</p><p>读取文件进行处理， 是这样的，readfile 是异步的，readfileSync 是同步的。</p><pre tabindex=0><code>fs.readfile(&#39;/etc/passwd&#39;, function(err, data) {
  if(err) throw err;
  console.log(data);
});
</code></pre><p>上面代码中， readfile 函数的第二个参数， 就是回调函数， 也就是任务的第二段。 等到操作系统返回了 / etc / passwd这个文件以后， 回调函数才会执行。</p><p>==一个有趣的问题是， 为什么 node.js 约定， 回调函数的第一个参数， 必须是错误对象 err（ 如果没有错误， 该参数就是 null）？ 原因是执行分成两段， 在这两段之间抛出的错误， 程序无法捕捉， 只能当作参数， 传入第二段。==</p><p><strong>3. promise</strong></p><p>“想像一下你是个小孩，你妈妈 promise 承诺你下星期给你一部新手机”</p><p>只有下周来临的时候，你才会知道你真的得到一部手机，或者是骗你玩的。</p><p>这就是 <strong>promise</strong>. 一个 promise 有三种状态：</p><ol><li>Pending: 待定，你不知道你是否能得到一部手机</li><li>Resolved: 妈妈很高兴，你得到一部手机</li><li>Rejected: 妈妈不高兴，你没有得到一部手机</li></ol><p>状态图如下：</p><p><img alt=image-20220527222312367 loading=lazy src=/posts/20220524-javascripts_promise/image-20220527222312367.png></p><p>语法很简单：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// promise syntax look like this
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span> <span class=p>);</span>
</span></span></code></pre></div><p>再看一下上面问题的解决方法：</p><p>首先确定 Mom 的状态是 unhappy，然后建立一个 Promise 来确定是否得到手机，最后用一个函数 askMom 来调用这个 Promise</p><p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作。</p><p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p><p>但是请注意以下两点：</p><ul><li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li><li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li></ul><pre tabindex=0><code class=language-javascripts data-lang=javascripts>var isMomHappy = false;

// Promise
var willIGetNewPhone = new Promise(
    function (resolve, reject) {
        if (isMomHappy) {
            var phone = {
                brand: &#39;Samsung&#39;,
                color: &#39;black&#39;
            };
            resolve(phone); // resolved
        } else {
            var reason = new Error(&#39;mom is not happy&#39;);
            reject(reason); // rejected
        }

    }
);

var askMom = function () {
    willIGetNewPhone
        .then(function (fulfilled) {
            // yay, you got a new phone
            console.log(fulfilled);
             // output: { brand: &#39;Samsung&#39;, color: &#39;black&#39; }
        })
        .catch(function (error) {
            // oops, mom didn&#39;t buy it
            console.log(error.message);
             // output: &#39;mom is not happy&#39;
        });
};

askMom();
</code></pre><p>很有点意思吧。抽象了，那就实际点。</p><p>javascripts 中的 fetch 函数就是基于Promise范式的，promise 的 resolves 绑在了 Response 上。Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl>    <span class=nx>fetch</span><span class=p>(</span><span class=s2>&#34;http://192.168.1.6/graph_image_hubot.php?action=view&amp;local_graph_id=13619&amp;rra_id=5&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=p>=&gt;</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nx>response</span><span class=p>.</span><span class=nx>ok</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=nx>response</span><span class=p>.</span><span class=nx>buffer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Network response was not ok.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>buffer</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kr>const</span> <span class=nx>formData</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>FormData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=nx>formData</span><span class=p>.</span><span class=nx>append</span><span class=p>(</span> <span class=s1>&#39;media&#39;</span><span class=p>,</span> <span class=nx>buffer</span><span class=p>,</span> <span class=p>{</span><span class=nx>filename</span><span class=o>:</span> <span class=s1>&#39;bandwidth.png&#39;</span><span class=p>,</span> <span class=nx>contentType</span><span class=o>:</span> <span class=s1>&#39;image/png&#39;</span> <span class=p>}</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nx>robot</span><span class=p>.</span><span class=nx>wwork</span><span class=p>.</span><span class=nx>sendImageMessage</span><span class=p>(</span><span class=nx>owner</span><span class=p>,</span> <span class=nx>formData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span></code></pre></div><p>上面的程序实际上是从 cacti 服务器拿到一张流量图片，然后 fetch 的结果 anyway，response总是有东西的，都会是成功的，所以我们必须再用 response.ok 来判断，成功就继续得到 buffer 流，最终送到 hubot 中去。三个过程用 then 串了起来，每一步都成功才会进行下一步。</p><p>这样写避免了回调地狱，看起来也比较舒服。</p><p>那什么时候用 promise 呢，它是异步的，有大IO读写硬盘、读写网络的时候用，上面是读写网络。下面再来一个读写磁盘的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span><span class=nx>promise</span><span class=o>:</span> <span class=p>{</span><span class=nx>readFile</span><span class=p>,</span> <span class=nx>writeFile</span><span class=p>}}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fs&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=kr>async</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>content</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>readFile</span><span class=p>(</span><span class=s1>&#39;./data.txt&#39;</span><span class=p>,</span> <span class=s1>&#39;utf8&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>await</span> <span class=nx>writeFile</span><span class=p>(</span><span class=s1>&#39;2.txt&#39;</span><span class=p>,</span> <span class=nx>content</span><span class=p>,</span> <span class=s1>&#39;utf8&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;ok&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})();</span>
</span></span></code></pre></div><p>上面的语法是 ES7 的，它更尽了一步，首先声明一个匿名的函数是 async 异步的，然后用await来进行等待，将读和写两个大操作都放到 await 的一步操作中去，这样程序看起来就变成同步的一步步等待了。跟 ES6 的 promise 比起来，更进了一步。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://rendoumi.com/posts/20220609-shell_tips/><span class=title>« 上一页</span><br><span>Shell进阶技巧</span>
</a><a class=next href=https://rendoumi.com/posts/20220523-javascripts_map/><span class=title>下一页 »</span><br><span>javascripts中的map</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share javascripts中的promise on x" href="https://x.com/intent/tweet/?text=javascripts%e4%b8%ad%e7%9a%84promise&amp;url=https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share javascripts中的promise on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f&amp;title=javascripts%e4%b8%ad%e7%9a%84promise&amp;summary=javascripts%e4%b8%ad%e7%9a%84promise&amp;source=https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share javascripts中的promise on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f&title=javascripts%e4%b8%ad%e7%9a%84promise"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share javascripts中的promise on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share javascripts中的promise on whatsapp" href="https://api.whatsapp.com/send?text=javascripts%e4%b8%ad%e7%9a%84promise%20-%20https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share javascripts中的promise on telegram" href="https://telegram.me/share/url?text=javascripts%e4%b8%ad%e7%9a%84promise&amp;url=https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share javascripts中的promise on ycombinator" href="https://news.ycombinator.com/submitlink?t=javascripts%e4%b8%ad%e7%9a%84promise&u=https%3a%2f%2frendoumi.com%2fposts%2f20220524-javascripts_promise%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=comments></div><script src=https://cwd.js.org/cwd.js></script><script>const comments=new CWDComments({el:"#comments",apiBaseUrl:"https://cwd.rendoumi.qzz.io"});comments.mount()</script></article></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>