<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>所有文章 | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content="所有文章 - 八戒的技术博客"><meta name=author content="八戒"><link rel=canonical href=https://rendoumi.com/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5d8a858b4ad07d913988e10d3c3dbc8c171f45316a396de8a60d67f44840812d.css integrity="sha256-XYqFi0rQfZE5iOENPD28jBcfRTFqOW3opg1n9EhAgS0=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://rendoumi.com/posts/index.xml title=rss><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="所有文章"><meta property="og:description" content="专注于Linux运维技术"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="所有文章"><meta name=twitter:description content="专注于Linux运维技术"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="Home (Alt + H)"><img src=https://rendoumi.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://rendoumi.com/>主页</a></div><h1>所有文章
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>systemd与journalctl的双剑合璧
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>时代已经进化到 systemd 的年代了，service 应该是彻底没有市场了
systemd 的好处是写程序的时候再也不用 fork 甩脱父进程了，日志直接输出终端即可
对 java 来说也是个好事，所有的日志比如WARN ERROR INFO都可以交给journal来管理，这样要查找日志也非常方便了。
举个例子，我们要把一个java启动的程序做成 systemd 的：
vim /etc/systemd/system/circle.service
[Unit] After=network.target Wants=network.target [Service] WorkingDirectory=/export/prod/server Type=simple ExecStart=/usr/bin/java -jar -Dspring.config.location=application.properties -Dlog4j2.formatMsgNoLookups=true server.jar Restart=on-failure RestartSec=1s [Install] WantedBy=multi-user.target 然后就可以运行了：
systemctl daemon-reload systemctl start circle 注意上面的WorkingDirectory，因为下面java启动指定 application.properties 配置文件的时候没有用绝对路径，那么这里就要指定当前工作目录了。
另外RestartSec=1s也改了，缺省是10ms，太快了
当然这只是第一步，日志是归journal管了，journal还是需要进一步配置的
首先必须要持久化存储到磁盘，否则只会在/run/log/journal内存中存放，重启就没了
#disk-usage查看的是: 内存+/var/log/journal的加起来的总和大小 journalctl --disk-usage 然后我们需要修改配置，让它持久化
vi /etc/systemd/journald.conf Storage=persistent 修改重启
mkdir /var/log/journal systemd-tmpfiles --create --prefix /var/log/journal systemctl restart systemd-journald 最后刷一下，把内存的文件刷到磁盘中
journalctl --flush 还可以设置保存天数：
journalctl --vacuum-time=31d 查看是从那一天开始保存的，进目录查看时间戳即可
cd /var/log/journal ls -lha 最后就是一个秘籍了，如果把日志弄出来查看
journalctl -u circle --since "2022-10-19 14:30:00" --until "2022-10-19 15:00:00" 开发人员经常问我要日志，这样就特别方便快捷了，比从log4j的日志目录里拉方便的多。
...</p></div><footer class=entry-footer><span title='2022-10-19 09:30:11 +0800 CST'>2022年19月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>85 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to systemd与journalctl的双剑合璧" href=https://rendoumi.com/posts/20220925-awk_usage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>awk的用法
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>awk 是比较强力的工具，跟cut和sed组合起来，会有意想不到的作用
举个简单例子，我们nginx的access.log如下：
110.244.232.88 - - [12/Apr/2022:16:50:06 +0800] help.jjwxc.net "GET /user/article/248 HTTP/1.1" 200 10616 "http://my.jjwxc.net/"
220.244.232.88 - - [12/Apr/2022:16:50:06 +0800] help.jjwxc.net "GET /user/article/248 HTTP/1.1" 200 20616 "http://my.jjwxc.net/"
330.244.232.88 - - [12/Apr/2022:16:50:06 +0800] help.jjwxc.net "GET /user/article/248 HTTP/1.1" 200 30616 "http://my.jjwxc.net/"
410.244.232.88 - - [12/Apr/2022:16:50:06 +0800] help.jjwxc.net "GET /user/article/248 HTTP/1.1" 200 10616 "http://my.jjwxc.net/"
530.244.232.88 - - [12/Apr/2022:16:50:06 +0800] help.jjwxc.net "GET /user/article/248 HTTP/1.1" 200 10616 "http://my.jjwxc.net/"
650.244.232.88 - - [12/Apr/2022:16:50:06 +0800] help.jjwxc.net "GET /user/article/248 HTTP/1.1" 200 50616 "http://my.jjwxc.net/"
760.244.232.88 - - [12/Apr/2022:16:50:06 +0800] help.jjwxc.net "GET /user/article/248 HTTP/1.1" 200 60616 "http://my.jjwxc.net/" 第一个字段是ip，然后倒数第3个是200，表示200 OK，后面的就是传输了多少数据两给客户端 我们要统计一下流量大的前5名是谁。
...</p></div><footer class=entry-footer><span title='2022-09-25 09:30:11 +0800 CST'>2022年25月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>135 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to awk的用法" href=https://rendoumi.com/posts/20221019-systemctl/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ansible之等待服务状态变成成功
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>ansible的脚本中我们可能会要启动某项服务并等待，直到服务启动起来，然后再进行下一步
这个非常重要，我们举例来实验一下：
- hosts: localhost vars: local__service: ssh tasks: - block: - name: "Stop {{ local__service }} service" systemd: service: "{{ local__service }}" state: stopped - name: "Populate ansible_facts.services variable" ansible.builtin.service_facts: - name: "{{ local__service }} state will be stopped as expected" assert: that: ansible_facts.services[local__service].state == 'stopped' - name: "Start {{ local__service }} service" systemd: service: "{{ local__service }}" state: started - name: "Registered {{ local__service }} state will still be stopped as it was not refreshed" assert: that: ansible_facts.services[local__service].state == 'stopped' - name: "Refresh ansible_facts.services variable" ansible.builtin.service_facts: - name: "{{ local__service }} state will be running as expected" assert: that: ansible_facts.services[local__service].state == 'running' 上面的 playbook 一共有7步：
...</p></div><footer class=entry-footer><span title='2022-07-29 09:30:11 +0800 CST'>2022年29月</span>&nbsp;·&nbsp;<span>2 分钟</span>&nbsp;·&nbsp;<span>222 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to Ansible之等待服务状态变成成功" href=https://rendoumi.com/posts/20220729-ansible_until/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LVM系统的Restore
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>在生产系统中使用LVM务必要注意lvm metadata的备份，曾经在京东的时候发生过虚机用了lvm的磁盘系统，然后虚机文件qcow2突然坏掉了，想尽了办法也无法恢复，这给我们拉响了警钟啊，使用lvm的时候务必要备份分区信息，否则坏的时候就欲哭无泪了。
缺省在 /etc/lvm/backup/ 目录下是最新的备份，同样历史版本都在 /etc/lvm/archive/ 目录下。
一、先备份 在开始恢复之前，一定先做个备份
cp -pr /etc/lvm /etc/lvm_bkp 然后去看看archive下的备份信息
ls -l /etc/lvm/archive/vg_storage_00* -rw-------. 1 root root 13722 Oct 28 23:45 /etc/lvm/archive/vg_storage_00419-1760023262.vg -rw-------. 1 root root 14571 Oct 28 23:52 /etc/lvm/archive/vg_storage_00420-94024216.vg ... -rw-------. 1 root root 14749 Nov 23 15:11 /etc/lvm/archive/vg_storage_00676-394223172.vg -rw-------. 1 root root 14733 Nov 23 15:29 /etc/lvm/archive/vg_storage_00677-187019982.vg # 二、最坏的情形恢复pv 警告：这一步只能在VG无法正常运行的时候再运行！！！
先说最坏的情形，LVM的建立路径是 pv —> vg —> lv，假设连 pv（物理卷都没了）
我们选择最近的备份，/etc/lvm/archive/vg_storage_00677-187019982.vg
less /etc/lvm/archive/vg_storage_00677-187019982.vg ... physical_volumes { pv0 { id = "BgR0KJ-JClh-T2gS-k6yK-9RGn-B8Ls-LYPQP0" ... 从里面拿到 pv 的 id ，重建 pv
pvcreate --uuid "BgR0KJ-JClh-T2gS-k6yK-9RGn-B8Ls-LYPQP0" \ --restorefile /etc/lvm/archive/vg_storage_00677-187019982.vg 三、恢复VG 如果 vg 是正常的，那么就不用做第二步了，直接从备份中恢复即可，先查看一下
...</p></div><footer class=entry-footer><span title='2022-07-28 09:30:11 +0800 CST'>2022年28月</span>&nbsp;·&nbsp;<span>4 分钟</span>&nbsp;·&nbsp;<span>646 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to LVM系统的Restore" href=https://rendoumi.com/posts/20220728-lvm_restore/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>dmesg -T 无时间戳的解决方法
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>现在版本的 dmesg -T 都是带时间戳的。
但是老的机器，很有可能是没有 -T 这个参数的，直接 dmesg 是这样的：
这个时间戳是天书啊，这还算好的，好歹有。还有更差的，连戳子都没有：
戳子都没有的，需要做以下步骤来加上，机器重启后必须再执行一遍：
echo 1 > /sys/module/printk/parameters/printk_time 同时写个脚本，/usr/local/bin/dmesgt.sh
#!/bin/bash # Translate dmesg timestamps to human readable format # desired date format date_format="%a %b %d %T %Y" # uptime in seconds uptime=$(cut -d " " -f 1 /proc/uptime) # run only if timestamps are enabled if [ "Y" = "$(cat /sys/module/printk/parameters/time)" ]; then dmesg | sed "s/^\[[ ]*\?\([0-9.]*\)\] \(.*\)/\\1 \\2/" | while read timestamp message; do printf "[%s] %s\n" "$(date --date "now - $uptime seconds + $timestamp seconds" +"${date_format}")" "$message" done else echo "Timestamps are disabled (/sys/module/printk/parameters/time)" fi 这样就可以了，最后我们测试一下：
...</p></div><footer class=entry-footer><span title='2022-07-25 09:30:11 +0800 CST'>2022年25月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>125 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to dmesg -T 无时间戳的解决方法" href=https://rendoumi.com/posts/20220725-dmesg_time/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>一次mongodb cpu很high的解决方法
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>接到同事的通知，说mongodb的cpu很高，下不去，看有什么办法。
看了一下图，cpu都99.4%了，确实很高：
登上机器，首先去看mongod的log，都试如下的查询，都很慢：
copy出一条来，备用
2022-07-17T21:30:42.556+0800 I COMMAND [conn196670] command beyou.behaviorAnalysis command: find { find: "behaviorAnalysis", filter: { behavior: { $regex: ".*互动操作.*", $options: "i" }, log: { $regex: ".*\Q观看：《罗马的房子》,\E.*", $options: "i" }, userId: 7345, _class: { $in: [ "com.linkyee.api.domain.po.BehaviorAnalysis" ] } }, $db: "beyou" } planSummary: IXSCAN { _class: 1, behavior: 1, log: 1, userId: 1 } keysExamined:111564 docsExamined:2 cursorExhausted:1 numYields:890 nreturned:2 reslen:571 locks:{ Global: { acquireCount: { r: 891 } }, Database: { acquireCount: { r: 891 } }, Collection: { acquireCount: { r: 891 } } } storage:{} protocol:op_msg 2268ms 发现确实很慢啊，op_msg 居然要2268ms，但是mongodb的数据目录总共才6G多，不客观啊。
...</p></div><footer class=entry-footer><span title='2022-07-21 09:30:11 +0800 CST'>2022年21月</span>&nbsp;·&nbsp;<span>2 分钟</span>&nbsp;·&nbsp;<span>248 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to 一次mongodb cpu很high的解决方法" href=https://rendoumi.com/posts/20220721-mongodb_cpu/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Infrastructure as Code中packer的使用
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>先普及一下概念，Infrastructure as Code，也就是从代码开始定义整个网络环境、虚机、各种资源等等。
简单说就是在云上用代码来管理一切，无论是vpc、subnetwork、lb、snat、sg、ec2……
非常符合我的胃口，因为就连架构图，都是用 graphviz 来画的。
那么 Infrastructure as Code （IAC） 可以分为以下五个部分：
Ad hoc scripts Configuration Management tools Orchestration tools Provisioning tools Server Templating tools 一、Ad hoc scripts 就是用软件对目的主机进行 point to point 操作，用shell或者ansible都可以。推荐ansible。
在 infosys 面试被一个印度老外问到这问题，因为平时根本不用ansible 的 ad hoc 点对点模式，结果被当场问住。现在才知道这玩意是什么。当然，用 ansible 的话不建议用这个，因为 playbook 是可追溯的。
二、Configuration Management tools 配置管理，这里当然推荐 ansible，每一步的操作都可以有 inventory 和 playbook 可以追溯。
三、Orchestration tools 协同工具，k8s和kvm
四、Provisioning tools 生产工具，当然是terraform，另外，阿里云是支持plumi的，华为腾讯不支持。
五、Server Templating tools 模板工具，这里就是 Packer，其实我们公司现在的模板工具，是八戒从openstack学的，改动Cloud-init的东西。
Packer更标准一下，是进化版的东西，它既可以打kvm镜像，也可以打Docker镜像。
下面我们就看看怎么使用吧，这里先说kvm，因为kvm的比较难，docker的八戒现在还是用Dockerfile，有空了再研究packer：
安装就不多说了，就一个执行文件，下载下来就行，不用装。
Packer的核心是三个部分
builders provisioners post-processors 我们先建立一个空目录，名字随便，就叫 test-image
...</p></div><footer class=entry-footer><span title='2022-07-17 10:30:11 +0800 CST'>2022年17月</span>&nbsp;·&nbsp;<span>2 分钟</span>&nbsp;·&nbsp;<span>273 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to Infrastructure as Code中packer的使用" href=https://rendoumi.com/posts/20220717-terraform/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cisco设备自动执行和备份的脚本
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>在日常工作中我们经常要对 Cisco 的网络设备的配置进行备份，或者和 suricata 联动的时候要执行操作。
方法其实很简单，调用 python 的相应模块即可。
准备工作如下：
首选需要在/export/servers/python363装好 python 3.6, pip install netmiko
其次，在路由器上可以配置en的密码
然后依次执行备份就可以了。
#!/export/servers/python363/bin/python3.6 from netmiko import Netmiko import time tw_bgp = { "device_type": "cisco_ios", "host": "tw-bgp", "ip": "192.168.1.10", "username": "noc", "use_keys": True, "secret" : "xxxxxxxx", "key_file": "/root/.ssh/id_jump_rsa_new", } tw_r1_e1 = { "device_type": "cisco_ios", "host": "tw-r1-e1", "ip": "192.168.1.11", "username": "noc", "use_keys": True, "key_file": "/root/.ssh/id_jump_rsa_new", } tw_r1_e2 = { "device_type": "cisco_ios", "host": "tw-r1-e2", "ip": "192.168.1.12", "username": "noc", "use_keys": True, "key_file": "/root/.ssh/id_jump_rsa_new", } tw_r2_e1 = { "device_type": "cisco_ios", "host": "tw-r2-e1", "ip": "192.168.1.13", "username": "noc", "use_keys": True, "key_file": "/root/.ssh/id_jump_rsa_new", } tw_r2_e2 = { "device_type": "cisco_ios", "host": "tw-r2-e2", "ip": "192.168.1.14", "username": "noc", "use_keys": True, "key_file": "/root/.ssh/id_jump_rsa_new", } devices=[tw_bgp, tw_r1_e1, tw_r1_e2, tw_r2_e1, tw_r2_e2] for dev in devices: name = dev["ip"] connection = Netmiko(**dev) connection.enable() out = connection.send_command("show running-config") calender = time.strftime("%Y%m%d") file_name = '{}-{}.txt'.format(dev["host"],calender) file = open(file_name ,"w") file.write(out) file.close() connection.disconnect() print("BACKUP for %s done" %dev["host"])</p></div><footer class=entry-footer><span title='2022-07-17 09:30:11 +0800 CST'>2022年17月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>145 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to Cisco设备自动执行和备份的脚本" href=https://rendoumi.com/posts/20220717-backup_cisco/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>用户态的NFS Server
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>NFS Server 很常用，但是坑也是巨大的。之前在京东运维 Hadoop 集群的时候碰到过脑裂，原因就是 NFS 引起的。
关键 NFS 是内核态的，一旦崩溃，那么客户端的所有命令，ls、df、du等等，统统无反应，结果是很悲剧的。
下面要推荐一下 nfs-ganesha ，它是用户态的nfs-server，支持v3和v4，而nfs缺省是内核态的v3。
强烈推荐大家用这个，而不是用内核态的，并且 nfs-ganesha 还是支持 glusterFS 的。
yum install -y centos-release-nfs-ganesha30.noarch vi /etc/ganesha/ganesha.conf %include /etc/ganesha/exports/gv0.conf vi /etc/ganesha/exports/gv0.conf EXPORT{ Export_Id = 1 ; # Export ID unique to each export Path = "/mnt/upload"; Pseudo = /upload; FSAL { name = VFS; } Access_type = RW; # Access permissions Squash = No_root_squash; # To enable/disable root squashing Disable_ACL = TRUE; # To enable/disable ACL Protocols = "4" ; # NFS protocols supported Transports = "UDP","TCP" ; # Transport protocols supported SecType = "sys"; # Security flavors supported } #启动 systemctl restart nfs-ganesha #手动mount的方法 mount -t nfs -o soft,intr,rsize=8192,wsize=8192,timeo=900,proto=tcp,vers=4 192.168.31.2:/upload /mnt/nfs-upload #自动mount的方法 cat /etc/fstab 192.168.31.2:/upload /mnt/nfs-upload nfs rw,vers=4,addr=192.168.31.2,clientaddr=192.168.31.8 0 0 注意id对齐问题可能要用到rpcidmapd
...</p></div><footer class=entry-footer><span title='2022-07-06 09:30:11 +0800 CST'>2022年6月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>119 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to 用户态的NFS Server" href=https://rendoumi.com/posts/20220706-nfs_usermode/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JavaScript 到底是如何执行的呢 -- JS的作原理
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>JavaScript 到底是如何工作的？ 一、工作原理 JavaScript到底是：
同步还是异步？ 单线程还是多线程？ JavaScript 中的一切都发生在
Execution Context （执行上下文）中
您可以假设这个执行上下文 是一个大盒子或一个容器，在其中执行整个 JavaScript 代码。 这个大盒子里有两个组件： Memory（内存组件）：这是所有变量和函数存储为键值对的地方。这个**“内存组件”也称为变量环境**。因此，它是一种环境，其中所有这些变量和函数都存储为键值对。 Code（代码组件）：这是代码逐行执行的地方。这个“代码组件”也称为执行线程。所以，这个执行线程是一个单线程，整个代码一次只执行一行。 结论：JavaScript 是一种同步单线程语言。
单线程 意味着 JavaScript 一次只能执行一个命令。 同步单线程 意味着 JavaScript 一次只能以特定顺序每次执行一个命令。这意味着它只能在当前行完成执行后转到下一行。这就是同步单线程的意思。 很惊诧吧，实际 javascripts 有单线程 event loop 大循环来完成很多不可思议的事情。
二、实际工作过程分析 JavaScript 代码是如何执行的？ 当你运行 JavaScript 代码时会发生什么？
会创建一个Execution Context（执行上下文）。
让我们使用实际的代码来举个例子：
var n = 2; function square(num) { var ans = num * num; return ans; } var square2 = square(n); var square4 = square(4); 执行上述代码时，会创建 一个执行上下文
...</p></div><footer class=entry-footer><span title='2022-06-21 09:30:11 +0800 CST'>2022年21月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>190 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to JavaScript 到底是如何执行的呢 -- JS的作原理" href=https://rendoumi.com/posts/20220621-javascripts_how_to_run/></a></article><div class=pagination><ul class=pagination-list><li class="page-item first"><a class=page-link href=/posts/ aria-label="First Page"><span aria-hidden=true>&#9668;</span></a></li><li class="page-item prev"><a class=page-link href=/posts/page/28/ aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a class=page-link href=/posts/page/25/>25</a></li><li class=page-item><a class=page-link href=/posts/page/26/>26</a></li><li class=page-item><a class=page-link href=/posts/page/27/>27</a></li><li class=page-item><a class=page-link href=/posts/page/28/>28</a></li><li class="page-item active"><span class=page-link aria-current=page>29</span></li><li class=page-item><a class=page-link href=/posts/page/30/>30</a></li><li class=page-item><a class=page-link href=/posts/page/31/>31</a></li><li class=page-item><a class=page-link href=/posts/page/32/>32</a></li><li class="page-item next"><a class=page-link href=/posts/page/30/ aria-label=Next><span aria-hidden=true>&#187;</span></a></li><li class="page-item last"><a class=page-link href=/posts/page/37/ aria-label="Last Page"><span aria-hidden=true>&#9658;</span></a></li></ul><div class=total-pages>共 37 页</div></div></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>