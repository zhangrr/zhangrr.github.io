<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>所有文章 | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content="所有文章 - 八戒的技术博客"><meta name=author content><link rel=canonical href=https://rendoumi.com/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.181dcf08b5d0ad7a24019e99c09910b83c66dc2a9b7be7a1215b3bb7af4cc829.css integrity="sha256-GB3PCLXQrXokAZ6ZwJkQuDxm3Cqbe+ehIVs7t69MyCk=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://rendoumi.com/posts/index.xml title=rss><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="所有文章"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="所有文章"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="八戒的技术博客 (Alt + H)">八戒的技术博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>所有文章</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>生产环境Proxmox 7.02的安装和配置
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>其实我们的生产环境一直是 KVM ，然后用 shell 脚本控制虚机的生成，也是用到了 Cloud-init 的标准镜像。
听说 Proxmox 也很不错，于是想看看能否也在生产环境中用上
如果在生产环境中用，必须要让 proxmox 支持 cloud-init ，否则无意义，下面也说一下跑在生产的注意事项
首先我们用光盘安装：
然后第一个注意的地方就是硬盘，选 Options 后：
会冒出一堆选项，公司的生产环境，服务器如果没有 raid 卡是很奇怪的，所以 zfs 反而不是标配，因为我们会事先在 raid 卡上划分好硬盘，生产环境基本必然是 raid10 ，接下来就是 ext4 和 xfs 二选一了，八戒选 ext4 ，因为坏了好修理，xfs_repair 用起来相当龟毛：
那么，选定了 ext4 ，接下来就比较重要了
hdsize 1116.0 ，单位是G，这个是自动收集上来的，不用改
swapsize，交换分区大小，这个给 8 G（最大8G）
maxroot，这个分区是第一个分区，存放 iso 和 template 的，需要给够，100 G
minfree，第一个分区最小留多大，给 10 G（缺省16G）
maxvz，这个分区是第二个分区，存放实际的虚机文件，全都用上，什么也不填写
然后继续，国家选 china，Hostname 填写 proxmox-168-86-103.local，再填写好其他信息，就安装成功了。
打开网页，我们可以看到一个 local，100G，对应上面的 maxroot
然后 local-lvm ，就是剩余放虚机的空间
...</p></div><footer class=entry-footer><span title='2021-11-03 09:30:11 +0800 CST'>2021年11月3日</span></footer><a class=entry-link aria-label="post link to 生产环境Proxmox 7.02的安装和配置" href=https://rendoumi.com/posts/20211103-proxmox/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>k8s中nginx ingress的性能优化
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>kubernetes 中 nginx ingress 的优化分两部分
一、系统sysctl部分优化 首先是对nginx启动前的系统性能进行优化，这部分调整网络的缓冲区，减小闲置 socket 关闭的时间
以阿里 ACK 为例，我们可以编辑 deployments 的 nginx-ingress-controller
initContainers: - command: - /bin/sh - -c - | mount -o remount rw /proc/sys sysctl -w net.core.somaxconn=65535 sysctl -w net.ipv4.ip_local_port_range="1024 65535" sysctl -w net.ipv4.tcp_tw_reuse=1 sysctl -w fs.file-max=1048576 sysctl -w net.ipv4.tcp_keepalive_time = 300 sysctl -w net.ipv4.tcp_keepalive_probes = 5 sysctl -w net.ipv4.tcp_keepalive_intvl = 15 二、nginx ingress 参数优化 大家制动，nginx ingree 其实是做为一个中间代理，所以上下游的socket参数也需要优化
...</p></div><footer class=entry-footer><span title='2021-11-02 11:00:11 +0800 CST'>2021年11月2日</span></footer><a class=entry-link aria-label="post link to k8s中nginx ingress的性能优化" href=https://rendoumi.com/posts/20211102-ingress_nginx/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux内核sysctl内核参数优化
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>这篇是纯配置篇，解释都在配置里了，是生产服务器 sysctl.conf 的配置
### KERNEL ### # Reboot after 10sec. on kernel panic kernel.panic = 10 ### IMPROVE SYSTEM MEMORY MANAGEMENT ### # Increase size of file handles and inode cache fs.file-max = 2097152 # Insure we always have enough memory vm.min_free_kbytes = 8192 # Do less swapping vm.swappiness = 10 vm.dirty_ratio = 10 vm.dirty_background_ratio = 2 ### GENERAL NETWORK SECURITY OPTIONS ### # Avoid a smurf attack net.ipv4.icmp_echo_ignore_broadcasts = 1 # Turn on protection for bad icmp error messages net.ipv4.icmp_ignore_bogus_error_responses = 1 # Turn on syncookies for SYN flood attack protection net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 8192 # Turn on timestamping net.ipv4.tcp_timestamps = 1 # Turn on and log spoofed, source routed, and redirect packets net.ipv4.conf.all.log_martians = 1 net.ipv4.conf.default.log_martians = 1 # No source routed packets here net.ipv4.conf.all.accept_source_route = 0 net.ipv4.conf.default.accept_source_route = 0 # Turn on reverse path filtering net.ipv4.conf.all.rp_filter = 1 net.ipv4.conf.default.rp_filter = 1 # Make sure no one can alter the routing tables net.ipv4.conf.all.accept_redirects = 0 net.ipv4.conf.default.accept_redirects = 0 net.ipv4.conf.all.secure_redirects = 0 net.ipv4.conf.default.secure_redirects = 0 # Don't act as a router net.ipv4.ip_forward = 0 net.ipv4.conf.all.send_redirects = 0 net.ipv4.conf.default.send_redirects = 0 # Number of times SYNACKs for passive TCP connection. net.ipv4.tcp_synack_retries = 2 # Allowed local port range net.ipv4.ip_local_port_range = 1024 65000 # Protect Against TCP Time-Wait net.ipv4.tcp_rfc1337 = 1 # Decrease the time default value for tcp_fin_timeout connection net.ipv4.tcp_fin_timeout = 15 # Decrease the time default value for connections to keep alive net.ipv4.tcp_keepalive_time = 300 net.ipv4.tcp_keepalive_probes = 5 net.ipv4.tcp_keepalive_intvl = 15 # This means that the keepalive process waits 300 seconds for socket # activity before sending the first keepalive probe, and then resend # it every 15 seconds. If no ACK response is received for 5 consecutive # times (75s in this case), the connection is marked as broken. ### TUNING NETWORK PERFORMANCE ### # Disable IPv6 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 # Default Socket Receive Buffer net.core.rmem_default = 31457280 # Maximum Socket Receive Buffer net.core.rmem_max = 12582912 # Default Socket Send Buffer net.core.wmem_default = 31457280 # Maximum Socket Send Buffer net.core.wmem_max = 12582912 # Increase number of incoming connections net.core.somaxconn = 5000 # Increase number of incoming connections backlog net.core.netdev_max_backlog = 65536 # Enable TCP window scaling net.ipv4.tcp_window_scaling = 1 # Increase the maximum amount of option memory buffers net.core.optmem_max = 25165824 # Increase the maximum total buffer-space allocatable # This is measured in units of pages (4096 bytes) net.ipv4.tcp_mem = 65536 131072 262144 net.ipv4.udp_mem = 65536 131072 262144 # Increase the read-buffer space allocatable net.ipv4.tcp_rmem = 8192 87380 16777216 net.ipv4.udp_rmem_min = 16384 # Increase the write-buffer-space allocatable net.ipv4.tcp_wmem = 8192 65536 16777216 net.ipv4.udp_wmem_min = 16384 # Increase the tcp-time-wait buckets pool size to prevent simple DOS attacks net.ipv4.tcp_max_tw_buckets = 1800000 # TIME_WAIT socket policy # Note: if both enabled then disable # net.ipv4.tcp_timestamps for servers # behind NAT to prevent dropped incoming connections #net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_tw_reuse = 1 # Enable TCP MTU probing (in case of Jumbo Frames enabled) #net.ipv4.tcp_mtu_probing = 1 # Speedup retrans (Google recommended) net.ipv4.tcp_slow_start_after_idle = 0 net.ipv4.tcp_early_retrans = 1 # Conntrack # 288bytes x 131072 = 37748736 (~38MB) max memory usage #net.netfilter.nf_conntrack_max = 131072 #net.netfilter.nf_conntrack_tcp_loose = 1 #TCP的直接拥塞通告(tcp_ecn)关掉 net.ipv4.tcp_ecn = 0 #路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。 net.ipv4.route.gc_timeout = 100 #设定系统中最多允许在多少TCP套接字不被关联到任何一个用户文件句柄上。 #如果超过这个数字，没有与用户文件句柄关联的TCP 套接字将立即被复位 #防简单Dos net.ipv4.tcp_max_orphans = 655360 # NOTE: Enable this if machine support it # -- 10gbe tuning from Intel ixgb driver README -- # # turn off selective ACK and timestamps #net.ipv4.tcp_sack = 0 #net.ipv4.tcp_timestamps = 1 ** 注意，net.ipv4.tcp_tw_recycle 不要打开，在 NAT 环境中会出错，而且在 K8S 中也会因 NAT 导致 pod 出错，切记！！！**
...</p></div><footer class=entry-footer><span title='2021-11-02 10:30:11 +0800 CST'>2021年11月2日</span></footer><a class=entry-link aria-label="post link to Linux内核sysctl内核参数优化" href=https://rendoumi.com/posts/20211102-sysctl_conf/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux内核TCP连接Keep-Alive timeout的配置
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>Custom Configuration of TCP Socket Keep-Alive Timeouts 这是个古老的话题，我们在机器的优化中，需要设置 TCP Socket 的 Timeout 参数
用来加快 TCP 关闭无用闲置连接的时间
Linux 内核中有三个缺省参数:
tcp_keepalive_time 缺省是 7200 秒 tcp_keepalive_probes 缺省是 9 tcp_keepalive_intvl 缺省是 75 秒 处理流程如下：
一、客户端打开一个 TCP socket 连接，开始跟服务器通讯
二、如果这条 socket 连接空闲没有任何数据传输，静默了 tcp_keepalive_time 秒后，那么客户端会主动发送一个空的 ACK 包到服务器
三、那么，根据服务器是否回应了一个相应的 ACK 包来判断
ACK 未回应 等待 tcp_keepalive_intvl 秒，然后再发一个 ACK 包 重复以上等待并发送 ACK 包的过程，直到次数等于 tcp_keepalive_probes 如果第2步做完还收不到任何回应，发送一个 RST 包并关闭连接 回应了: 回到上述第二步 那么缺省情况下，7200+75×9，一个没有任何数据传输的 socket 才会被关闭，大概是2小时11分钟。
...</p></div><footer class=entry-footer><span title='2021-11-02 09:00:11 +0800 CST'>2021年11月2日</span></footer><a class=entry-link aria-label="post link to Linux内核TCP连接Keep-Alive timeout的配置" href=https://rendoumi.com/posts/20211102-tcp_keealive/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>shell以及find的多线程执行
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>这属于Shell的高级技巧了，我们可能需要在 bash 中并发 wget rsync 文件，下面就讨论一下这个问题。
首先从简单的单线程开始：
$ for i in $(seq 1 2); do echo $i; done 1 2 可以看到是顺序执行的，下面变多线程：
$ for i in $(seq 1 2); do echo $i & done [1] 245505 1 [2] 245506 2 [1] Done echo $i [2] Done echo $i 可以看到我们只把 ; 号改成了 & 号，程序就变成了多线程执行。
区别在于 ; 号会等待之前的命令执行完毕再执行下一条，而 & 不等待，直接继续执行下一条；相当于后台运行了前一条命令。
下面说说 find 的单线程和多线程：
find 的 exec 用法
$ find /path [args] -exec [cmd] {} \; {} 占位符号，存放find找到的记录 ; 对于每一条找到的单独记录，执行的cmd是一条一条单独执行的 执行的顺序如下: cmd result1; cmd result2; …; cmd result N $ find /path [args] -exec [cmd] {} \+ {} 占位符号，存放find找到的记录 + 对于找到的所有记录，执行的cmd是合并了所有记录集执行的 执行顺序如下: cmd result1 result2 … result N 多个exec可以串起来：
...</p></div><footer class=entry-footer><span title='2021-10-29 09:30:11 +0800 CST'>2021年10月29日</span></footer><a class=entry-link aria-label="post link to shell以及find的多线程执行" href=https://rendoumi.com/posts/20211029-bash_multithread/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux下的程序限速软件Trickle</h2></header><div class=entry-content><p>之前讲过如何对 opnvpn 总体限速，这次来了一个更严格的程序限速需求：
场景如下：
两个机房间有一条专线 100M
两个机房间需要同步数据，同步需要限制到60M，给别的程序留出带宽空间
传输是多个文件，用 rsync 并发传送
分析了一下脚本的核心部分
find . -type f | grep $(date -d"-1 day" +'%Y%m%d') |xargs -I % -P 30 rsync -auvPR % 192.168.9.17::mysql 发现是利用 xargs 的并发，-P 30 最大并发30个，启动了 rsync 同步
rsync 没有限速，这就麻烦了。
一、单文件单独限速 首先是使用 rsync 的 –bwlimit=600 参数，把速度限制为 600KB/s ，600×8=4800，单进程基本是5M的速度，最多只能跑12个了，就会跑到60M。
这样也不太对，尤其是 rsync 并发进程逐渐减少，少于12个的时候，这样就出现跑不满60M的现象。
二、多文件整体限速 那么 rsync 支持多文件传输 ，使用如下格式整体限速
rsync --bwlimit=7200 -auvPR 文件1 文件2 文件3 192.168.9.17::mysql 问题又来了，文件1 文件2 文件3 的路径非常长，而文件个数不定，有撑爆命令行单行长度限制的可能，也不可行
三、tc 使用 tc 可以控制源ip或者目的ip的带宽，但是本机网卡是万兆光卡，生产环境，每时每刻都有数据读写。
一旦错了，就直接完蛋了。也不太可行
四、杀器trickle 寻找了半天，终于找到了个大杀器trickle，可以对程序单独限速，也可以对一堆程序整体限速
安装：
...</p></div><footer class=entry-footer><span title='2021-10-28 11:30:11 +0800 CST'>2021年10月28日</span></footer><a class=entry-link aria-label="post link to Linux下的程序限速软件Trickle" href=https://rendoumi.com/posts/20211028-trickle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dockerfile的编写与调试技巧
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>Dockerfile 是造出镜像的基础，是必须熟知并了解的知识：
一、编写Dockerfile 先给个例子，是 minio 代理访问阿里的 OSS
FROM alpine:3.12 RUN apk add --update bash && rm -rf /var/cache/apk/* COPY minio.RELEASE.2020-04-15T19-42-18Z /data/minio.RELEASE.2020-04-15T19-42-18Z ENV MINIO_ACCESS_KEY=LTAI5tFFTbsxxxxxuLb ENV MINIO_SECRET_KEY=t78PyGnHZilxxxxxdxBCjvNgtVC5Y WORKDIR /data EXPOSE 9000 CMD ["/data/minio.RELEASE.2020-04-15T19-42-18Z","gateway","oss","http://oss-cn-shanghai-internal.aliyuncs.com"] # CMD /bin/sh -c "while true; do echo hi; sleep 10; done" 详细解释每一条语句：
FROM
基板，alpine 3.12 是个比较微小的版本，注意它的毛病，/bin/sh其实是busybox，没有/bin/bash，某些bash的函数功能支持不全，比如for循环
RUN
在容器中运行命令，上例中我们添加了 bash ，并清理了缓存。命令间用 && 可以避免镜像过多分层。
RUN分两种模式shell和exec模式:
我们只用 exec 模式，因为在 image 里装入多个 shell，没什么意义。
COPY 和 ADD
...</p></div><footer class=entry-footer><span title='2021-10-28 10:30:11 +0800 CST'>2021年10月28日</span></footer><a class=entry-link aria-label="post link to Dockerfile的编写与调试技巧" href=https://rendoumi.com/posts/20211028-dockerfile/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PHP程序如何发送syslog到远程服务器
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>给同事做了个 PHP 接口，转发发送短信的请求，同时要把发送记录发送到远程的 cacti 的 syslog 去
很简单，但是也不简单
首先是 PHP 服务器，是最简化编译的，php -m 查了一下
php -m [PHP Modules] Core ctype curl date dom fileinfo filter gettext hash iconv json libxml openssl pcre PDO pdo_sqlite Phar posix Reflection session SimpleXML SPL sqlite3 standard tokenizer xml xmlreader xmlwriter [Zend Modules] 居然没有 socket 模块，没办法，找到源代码，编译一个安装，原有的 php 安装路径是 /export/servers/php
$ tar zxvf php-7.4.0.tar.gz $ cd php-7.4.0/sockets $ /export/servers/php/bin/phpize $ ./configure --enable-sockets --with-php-config=/export/servers/php/bin/php-config $ make $ make install 又看了一眼，是 php-fpm，居然没有 php.ini ，得，再生成一个，放在 /export/servers/php/lib/php.ini
...</p></div><footer class=entry-footer><span title='2021-10-28 09:30:11 +0800 CST'>2021年10月28日</span></footer><a class=entry-link aria-label="post link to PHP程序如何发送syslog到远程服务器" href=https://rendoumi.com/posts/20211028-php_syslog/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>没有装Docker如何从镜像中释放出文件
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>用 kubernetes 越多，用 docker 越多，就愈发感觉到好处多多。
简简单单的一个可执行文件，用 docker 基板 alphine 封装，就可以运行起一个 pod ，然后指定 deployment、svc、ingress，就可以将服务暴露出去。
其实很多情况下单可执行文件 + systemd也是不错的选择。
这不就遇到个问题，ghostunnel 这个软件，github 只释放出了源代码以及 windows 、linux 和 mac 的三个可执行版本。
可我的执行环境是 nanopi ，是个 arm7 的架构，就无计可施了。
无奈下，在 nanopi 上装了 go ，编译了个 arm7 的出来。
但是遇到 vaultwanden ，rust 的，就没法弄了，vps 太弱，根本无法用 cargo 编译。
那怎么办呢？方法如下，不安装 Docker ，也可以把镜像中的文件抽取出来
$ mkdir vm $ wget https://raw.githubusercontent.com/jjlin/docker-image-extract/main/docker-image-extract $ chmod +x docker-image-extract $ ./docker-image-extract vaultwarden/server:alpine Getting API token... Getting image manifest for vaultwarden/server:alpine... Fetching and extracting layer a0d0a0d46f8b52473982a3c466318f479767577551a53ffc9074c9fa7035982e... Fetching and extracting layer 3a9a529931676767ec84d35ab19774b24bd94e20f6fff7e6bda57ef5f2a66cfc... Fetching and extracting layer f9dcfa9aefe67ce52ab2a73e515ea715d242348b8fc338dbe4ca72a853ea0318... Fetching and extracting layer 4249d8cece35148b5faca2c6a98d566a271a1996b127b14480793ee8825e43c0... Fetching and extracting layer 72f4873a62cc82eaf28905077df3791e3b235bf5d17670e7aff6d5fb5e280739... Fetching and extracting layer 8eb772c524f9d998c8c7c92acc5ba96e3e9ebfb175dbb2441fe6e7b7598874f5... Fetching and extracting layer 663794f103b44abb8a90e1376dce14735905e2f938b4ca7e0ff379b09cbf6148... Image contents extracted into ./output. 这样我们就可以在 output 目录下得到 vaultwarden 和 web-vault
...</p></div><footer class=entry-footer><span title='2021-10-27 10:30:11 +0800 CST'>2021年10月27日</span></footer><a class=entry-link aria-label="post link to 没有装Docker如何从镜像中释放出文件" href=https://rendoumi.com/posts/20211027-docker_extract_file/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bitwarden（vaultwarden）如何在非Docker环境下安装使用
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>为什么会有非 Docker 环境这个怪字眼呢？
无他，因为满网搜索到的教程都是在 Docker 环境下安装使用。
但是穷啊，八戒的 vps 是个单核 500m 的 justhost 机器，便宜的很，这种廉价机器来跑 Docker，基本要占100M，跑不太动。
这种一穷二白的环境，就只能把 Bitwarden 从容器里拆出来用。
好在 Bitwarden_rs 是一个 rust 程序，占内存(16M左右)和cpu极少，本身就适合在 systemd 环境下跑。
这里就利用 vaultwarden 和 traefik，在一台老破小服务器上运行。
系统环境是 CentOS 7.9
步骤如下：
一、下载bitwarden(vaultwarden) wget https://github.com/dani-garcia/vaultwarden/archive/refs/tags/1.23.0.tar.gz 二、安装cargo并编译（可选） yum install -y epel-release yum install -y openssl-devel cargo cd vaultwarden-1.23.0 cargo build --release --features sqlite 直接爆错啊，小小的 vps 连编译都过不去，编译进程都被 kill 掉了
三、下载vaultwarden主文件 编译不通，就只能想别的办法了。Faint
找一台有 docker 机器，从里面把文件都解析出来好了
docker pull vaultwarden/server:alpine docker create --name vw vaultwarden/server:alpine docker cp vw:/vaultwarden . docker cp vw:/web-vault . docker rm vw 这样会得到一个可执行文件 vaultwarden 和一个目录 web-vault
...</p></div><footer class=entry-footer><span title='2021-10-27 09:30:11 +0800 CST'>2021年10月27日</span></footer><a class=entry-link aria-label="post link to Bitwarden（vaultwarden）如何在非Docker环境下安装使用" href=https://rendoumi.com/posts/20211027-bitwarden/></a></article><div class=pagination><ul class=pagination-list><li class="page-item first"><a class=page-link href=/posts/ aria-label="First Page"><span aria-hidden=true>&#9668;</span></a></li><li class="page-item prev"><a class=page-link href=/posts/page/31/ aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a class=page-link href=/posts/page/25/>25</a></li><li class=page-item><a class=page-link href=/posts/page/26/>26</a></li><li class=page-item><a class=page-link href=/posts/page/27/>27</a></li><li class=page-item><a class=page-link href=/posts/page/28/>28</a></li><li class=page-item><a class=page-link href=/posts/page/29/>29</a></li><li class=page-item><a class=page-link href=/posts/page/30/>30</a></li><li class=page-item><a class=page-link href=/posts/page/31/>31</a></li><li class="page-item active"><span class=page-link aria-current=page>32</span></li><li class="page-item next"><a class=page-link href="?page=33" aria-label="Next Group"><span aria-hidden=true>&#187;</span></a></li><li class="page-item last"><a class=page-link href=/posts/page/34/ aria-label="Last Page"><span aria-hidden=true>&#9658;</span></a></li></ul><div class=total-pages>共 34 页</div></div></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>