<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3988508441804851" crossorigin=anonymous></script><title>所有文章 | 八戒的技术博客</title>
<meta name=keywords content><meta name=description content="所有文章 - 八戒的技术博客"><meta name=author content="八戒"><link rel=canonical href=https://rendoumi.com/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5d8a858b4ad07d913988e10d3c3dbc8c171f45316a396de8a60d67f44840812d.css integrity="sha256-XYqFi0rQfZE5iOENPD28jBcfRTFqOW3opg1n9EhAgS0=" rel="preload stylesheet" as=style><link rel=icon href=https://rendoumi.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rendoumi.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rendoumi.com/favicon-32x32.png><link rel=apple-touch-icon href=https://rendoumi.com/apple-touch-icon.png><link rel=mask-icon href=https://rendoumi.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://rendoumi.com/posts/index.xml title=rss><link rel=alternate hreflang=zh href=https://rendoumi.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://rendoumi.com/posts/"><meta property="og:site_name" content="八戒的技术博客"><meta property="og:title" content="所有文章"><meta property="og:description" content="专注于Linux运维技术"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rendoumi.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="所有文章"><meta name=twitter:description content="专注于Linux运维技术"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://rendoumi.com/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://rendoumi.com/ accesskey=h title="Home (Alt + H)"><img src=https://rendoumi.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://rendoumi.com/ title=首页><span>首页</span></a></li><li><a href=https://rendoumi.com/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://rendoumi.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.rendoumi.com title=生活><span>生活</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://rendoumi.com/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://rendoumi.com/>主页</a></div><h1>所有文章
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Caddy自动签发任意域名证书
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>公司的SAAS平台，本来多租户的证书管理模式预计是这样的：
给每个租户单独设立一个 xyz.alibaba.com 的子域名，然后用cert-manager管理证书，只要annouce一个 xyz.alibaba.com 的ingress出来，就会自动签发证书。
然而研发觉得这样也是很不爽，连annouce ingress也不愿意，就想客户的域名直接解析一个 xyz.客户.com 的 cname 过来，然后就自动签发证书。
这个需求真的是很有意思，也只有caddy能很轻松的这么实现，方法如下：
一、做好一个caddy的deploy和service，前面直接顶一个Loadbalance
二、配置caddy的配置
/etc/caddy/Caddyfile 的内容
{ debug on_demand_tls { ask http://localhost:5555/ } } https:// { tls { on_demand } handle { reverse_proxy https://alibaba.com { header_up Host alibaba.com } } respond "Welcome to dynamic certificate signing!" 200 } http://localhost:5555 { respond 200 } 注意上面，Caddy对这种随便的域名，是要求去问一下后端的服务是否对这个域名进行签发的，这是为了防止滥用。
我们直接做个虚拟服务，回应200即可
这样的做法比较直接了当，当然只适用于国外，国内就麻烦了，未知的域名解析到你的ip上，没备案直接就会被封站。</p></div><footer class=entry-footer><span title='2025-11-10 09:02:11 +0800 CST'>2025年10月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>57 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to Caddy自动签发任意域名证书" href=https://rendoumi.com/posts/20251110-caddy_wild_certificate/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AWS的ECS使用Fargate服务器如何开启shell进入容器调试
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>公司用到了Amazon Elastic Container Service，完全托管的容器服务
服务器用的是Fargate，没有自己的服务器，纯托管的，开始部署的时候，也没有考虑到有一天要进入容器进行调试。
现在麻烦就来了，需要进入容器，查看文件日志
结果就很麻烦，解决的步骤如下：
一、查看集群状态，看看任务定义的版本号，下面是206 二、去到相应的任务定义 注意，现在只有一个任务执行角色，任务角色是个空的！！！
然后我们点开任务执行角色，添加权限
初始化的时候只有AmazonECSTaskExecutionRolePolicy, 我们需要加上AmazonSSMManagedInstanceCore
加完就上面一样。
三、返回到任务定义，使用JSON创建新修订 "taskRoleArn": "arn:xxxx:ecsTaskExecutionRole", "executionRoleArn": "arn:ecsTaskExecutionRole", 新增taskRoleArn，和executionRoleArn保持一致，然后保存
四、按照新版本，部署新任务 从新任务定义更新服务
选择相应集群，相应服务
故障排除配置，务必开启ECS exec，然后更新即可
五、开启容器的shell 我去集群–服务–容器，点击连接
aws ecs execute-command --cluster yoov_work_e_form_prod_cluster --task 23xxxxx --container yontainer --interactive --command '/bin/sh' 实际对应的命令如上。其实也可以用aws的cli客户端直接执行，只不过要拿到集群名和容器名。</p></div><footer class=entry-footer><span title='2025-11-10 09:01:11 +0800 CST'>2025年10月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>40 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to AWS的ECS使用Fargate服务器如何开启shell进入容器调试" href=https://rendoumi.com/posts/20251110-aws-ecs_fargate/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MongoDB的伪副本模式
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>这个话题比较有意思，公司的测试环境本来是一个mongodb的三节点三副本全集群，升级了2次升到8.0。
结果吧，由于里面数据过于庞大，测试的时候经常把节点打挂，虽说是打挂后又能很快被docker拉起来，但是挂的那个时刻应用程序就掉了，导致测试失败。
这三台节点还都是8 cpu 32G memory的配置，真大无语了。
没办法，干脆弄成单节点，然后内存垒高到128G，cpu加到32，弄好之后，读取数据的Flink又不行了，要求是必须读mongo的副本，真完犊子。
那就强制启动个副本模式吧：
mongo启动方式用的是docker compose，启动的时候新增参数 --replSet rs0
# mongo数据目录的属主是 999:999 mkdir -p /data/mongodb/27017/data chown -R 999:999 /data/mongodb/27017/data mkdir -p /data/mongodb/27017/conf/ cd /data/mongodb/27017 #先gen keyfile openssl rand -base64 756 > keyfile chmod 400 keyfile #准备mongod.conf EOF &lt; cat > /data/mongodb/27017/conf/mongod.conf systemLog: destination: file path: "/data/db/mongod.log" logAppend: true net: bindIp: 0.0.0.0 port: 27017 security: keyFile: "/data/configdb/keyfile" EOF EOF &lt; cat > /data/mongodb/docker-compose.yaml services: mongo: container_name: mongo image: mongo:8.0 restart: always environment: TZ: Asia/Shanghai volumes: - /data/mongodb/27017/data:/data/db - /data/mongodb/27017/conf/mongod.conf:/data/configdb/mongod.conf - ./keyfile:/data/configdb/keyfile command: --replSet rs0 --config /data/configdb/mongod.conf ports: - 27017:27017 EOF docker compose up -d 然后不算完啊，启动之后需要进入容器执行rs.initiate(), 放心大胆的执行，不会破坏任何原有的数据
...</p></div><footer class=entry-footer><span title='2025-10-29 09:01:11 +0800 CST'>2025年29月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>112 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to MongoDB的伪副本模式" href=https://rendoumi.com/posts/20251029-mongodb-rs0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>cert-manager的不同clusterissuer验证方式
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>cert-manager普通签发证书的时候，通常是DNS的A记录已经解析到相关的Ingress前置的LB 公网IP了。
第一种情况，有公网IP的证书签发，验证方式是http 那准备好cluster-issuer.yaml
apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: letsencrypt-prod1 spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: zhangranrui@rendoumi.com privateKeySecretRef: name: letsencrypt-prod1 solvers: - http01: ingress: class: nginx 第二种情况，如果集群是部署在内网，根本没有公网ip，就不能通过80和443的验证来签发了，只能用DNS校验的方式来签发证书 那以cloudflare托管的DNS为例，我们需要拿到CF的dns-api的token，然后声明，再定义ClusterIssuer
--- apiVersion: v1 kind: Secret metadata: name: cloudflare-api-token-secret type: Opaque stringData: api-token: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --- apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: letsencrypt-prod2 spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: zhangranrui@rendoumi.com privateKeySecretRef: name: letsencrypt-prod2 solvers: - dns01: cloudflare: email: zhangranrui@rendoumi.com apiTokenSecretRef: name: cloudflare-api-token-secret key: api-token 那第一种和第二种的区别就是solvers是不同的。
...</p></div><footer class=entry-footer><span title='2025-10-24 09:01:11 +0800 CST'>2025年24月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>110 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to cert-manager的不同clusterissuer验证方式" href=https://rendoumi.com/posts/20251024-certmanager_issuer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OPNsense的远程安装并访问WEBGUI
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>OPNsense安装其实很容易，但是远程装就不那么好玩了。
尤其涉及到内网WEBGUI的访问，缺省安装完成以后，只能从内网口访问管理界面，问题是VPC里只有一台Linux机器，还没有浏览器，怎么办？
记录一下安装过程，备查：
一、下载iso镜像并解压 wget https://pkg.opnsense.org/releases/25.7/OPNsense-25.7-dvd-amd64.iso.bz2 bzip2 -d OPNsense-25.7-dvd-amd64.iso.bz2 二、kvm用virt-install安装iso，注意桥接了2个网卡 #!/bin/bash mkdir -p /export/kvm/opn/ qemu-img create -f qcow2 /export/kvm/opn/opn.qcow2 20G virt-install \ --name=opn \ --vcpu=2 \ --ram=2048 \ --disk path=/export/kvm/opn/opn.qcow2,format=qcow2,size=20 \ --cdrom=/export/kvm/iso/OPNsense-25.7-dvd-amd64.iso \ --network bridge=br0,model=virtio \ --network bridge=br1,model=virtio \ --os-type unix \ --os-variant freebsd13.1 \ --vnc --vnclisten=0.0.0.0 --vncport=5901 三、vnc连到port 5901上进行安装配置 OPNsense公网的网卡、ip、mask、gateway配置
OPNsense内网的网卡、ip、mask配置
四、设置内网访问 这里就非常鬼畜了，首先在内网的那台机器上做port转发，这台机器是192.168.100.2，做个systemd的service:
cat /etc/systemd/system/opn-proxy.service [Unit] After=network.target Wants=network.target [Service] WorkingDirectory=/usr/local/bin/ Type=simple ExecStart=/usr/local/bin/go-tcp-proxy_1.0.2_linux_amd64 -l ":4430" -r "192.168.100.1:4430" Restart=on-failure RestartSec=1s [Install] WantedBy=multi-user.target 如上的话，如果web访问http://192.168.100.2:4430，那Host: 192.168.100.1 会被转发给 192.168.100.1 的OPNsense的4430端口
那OPNsense的内网IP是192.168.100.1，登录用户是root，密码是xxxxxxxx
从vnc上登录，然后进入shell，找到webgui的部分，添加port和althostnames的两项
vi /conf/config.xml ...... &lt;webgui> &lt;protocol>https&lt;/protocol> &lt;ssl-certref>68adc26101eeb&lt;/ssl-certref> &lt;port>4430&lt;/port> &lt;althostnames>192.168.100.2&lt;/althostnames> &lt;/webgui> ...... 然后重启webgui
...</p></div><footer class=entry-footer><span title='2025-10-23 09:01:11 +0800 CST'>2025年23月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>95 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to OPNsense的远程安装并访问WEBGUI" href=https://rendoumi.com/posts/20251023-opnsense_install/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>strapi的安装
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>老实说，strapi的安装真的不是一件容易的事情。
第一步想简单化，于是就用Docker compose来安装，结果并不容易，官方文档不可用，改了半天终于跑起来，然后，嘿嘿，dockerhub上的strapi:latest 早就过期很久了。
于是又琢磨它那个Docker build版本的，问题是，都在宿主机环境build出来了，然后再放到Docker镜像中跑，岂不是脱裤子放屁，多此一举么。
于是回到原点，需要在CLI环境下安装，然后要部署到正式生产环境。
步骤如下：
一、装mysql 8.0 apt install wget lsb-release gnupg -y wget https://dev.mysql.com/get/mysql-apt-config_0.8.29-1_all.deb dpkg -i mysql-apt-config_0.8.29-1_all.deb apt update apt install mysql-server 二、装NVM，nodejs和yarn curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash source ~/.nvm/nvm.sh nvm ls-remote nvm install v20.19.5 node -v npm install -g yarn npm list -g 三、初始化strapi mkdir /data cd /data yarn create strapi # 我们要跳过它那个免费30天的grow方案 # 然后数据库是 mysql , 填入mysql的一系列参数 # 使用ts 四、配置strapi # 加入自己的域名 vi /data/strapi/config/server.ts export default ({ env }) => ({ host: env('HOST', '0.0.0.0'), port: env.int('PORT', 1337), url: 'https://blog.rendoumi.com', app: { keys: env.array('APP_KEYS'), }, }); # 建立新文件 vi /data/strapi/src/admin/vite.config.ts import { defineConfig, mergeConfig } from 'vite'; export default (config) => { return mergeConfig(config, defineConfig({ resolve: { alias: { '@': '/src', }, }, server: { allowedHosts: true } })); }; 五、安装nginx，运行程序 apt install nginx # 注释掉无用配置 vi /etc/nginx/nginx.conf # include /etc/nginx/sites-enabled/*; # 新增配置 vi /etc/nginx/conf.d/strapi.conf upstream strapi { server 127.0.0.1:1337; } server { # Listen HTTP listen 80; server_name blog.rendoumi.com; # Redirect HTTP to HTTPS return 301 https://$host$request_uri; } server { # Listen HTTPS listen 443 ssl; server_name webcms.yoov.com; # SSL config ssl_certificate /usr/local/bin/certs/certificates/blog.rendoumi.com.crt; ssl_certificate_key /usr/local/bin/certs/certificates/blog.rendoumi.com.key; # Proxy Config location / { proxy_pass http://strapi; proxy_http_version 1.1; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "Upgrade"; proxy_pass_request_headers on; } } cd /data/strapi yarn develop 然后登录就可以了，诡异的是第四步，如果不gen vite.config.ts，那nginx代理访问local host:1337上会出问题。
...</p></div><footer class=entry-footer><span title='2025-10-16 09:01:11 +0800 CST'>2025年16月</span>&nbsp;·&nbsp;<span>2 分钟</span>&nbsp;·&nbsp;<span>233 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to strapi的安装" href=https://rendoumi.com/posts/20251016-strapi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NVM管理的Nodejs如何做成systemd的serivce服务
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>有很多next、nuxt、yarn的nodejs程序，都是什么npm start或者yarn develop的启动模式，如何搞成systemd的服务呢，这里面麻烦的就是systemd的服务需要使用全路径。
那方法如下：
一、安装nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash 二、安装nodejs和yarn source ~/.nvm/nvm.sh nvm ls-remote nvm install v20.19.5 node -v npm install -g yarn npm list -g 三、弄strapi.service服务 echo $NVM_DIR # 确定 nvm 的安装目录 /root/.nvm which node # 确定 Node.js 的路径 /root/.nvm/versions/node/v20.19.5/bin/node which yarn # 确定 Yarn 的路径 /root/.nvm/versions/node/v20.19.5/bin/yarn cat &lt; EOF > /etc/systemd/system/strapi.service [Unit] Description=Strapi App After=network.target [Service] # 使用用户账户运行服务，替换为实际的用户名 User=root Group=root # 指定工作目录，替换为项目的实际路径 WorkingDirectory=/data/strapi # 加载 nvm 并运行 yarn 或 node Environment="NVM_DIR=/root/.nvm" ExecStart=/bin/bash -c ". $NVM_DIR/nvm.sh && yarn develop" Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF systemctl daemon-reload systemctl enable --now strapi</p></div><footer class=entry-footer><span title='2025-10-15 09:10:11 +0800 CST'>2025年15月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>92 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to NVM管理的Nodejs如何做成systemd的serivce服务" href=https://rendoumi.com/posts/20251015-nodejs_systemctl/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- Nginx篇
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>新托管了一个机房服务器，基本全用开源软件来构建：
那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用
结构图如下，证书是放在了Nginx ingres上：
那方法有很多，各有利弊，说下第三个，Nginx的做法
relayd和caddy都说完了，那还有Nginx，Nginx的话，如果证书挂在OPNsense，那就可以用WAF的功能
如果证书放在后端Kubernetes的Nginx ingress上，那就无法用WAF了，算是data stream
那提前说一句，Nginx的配置是有Bug的，如果无法清除干净，需要ssh登录opnsense，然后
把 /conf/下xml配置文件中的 nginx 部分删除掉，然后重启服务器，才可以
os-nginx的配置方法如下：
第一步：首先去Upstream的Upstream Server子标签，建立两组服务器
第二步：再去Upstream的Upstream子标签，建立两组服务
建立的时候advanced mode要打开，PROXY Protocol要选中，Server选中各自的4个服务器，其它保持缺省即可。
第三步：去Data Streams的子标签Stream Servers，建两组服务
编辑一下，监听端口只选指定IP的80和443，PROXY Protocol不要选中，然后Route就选Upstream，Upstream Servers选中对应的，其它缺省即可。
那对应的，后端Kubernetes的Nginx ingress也要做相应配置
Nginx ingress的configmap，需要加上Proxy Protocol的部分
我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中
configmap ingress-nginx-controller，内容如下，对应data那两行：
apiVersion: v1 data: use-proxy-protocol: "true" kind: ConfigMap metadata: annotations: meta.helm.sh/release-name: ingress-nginx meta.helm.sh/release-namespace: ingress-nginx nginx.ingress.kubernetes.io/configuration-snippet: "true" nginx.ingress.kubernetes.io/location-snippet: "true" nginx.ingress.kubernetes.io/server-snippet: "true" creationTimestamp: "2025-08-27T07:38:49Z" labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.13.1 helm.sh/chart: ingress-nginx-4.13.1 name: ingress-nginx-controller namespace: ingress-nginx resourceVersion: "22298827" uid: d6eeef3c-7e44-4667-854a-c7693006b221 编辑后，nginx ingress会自动reload
...</p></div><footer class=entry-footer><span title='2025-10-14 09:10:11 +0800 CST'>2025年14月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>91 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- Nginx篇" href=https://rendoumi.com/posts/20251014-opensense_nginx/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>新托管了一个机房服务器，基本全用开源软件来构建：
那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用
结构图如下，证书是放在了Nginx ingres上：
那方法有很多，各有利弊，说下第二个，Caddy的做法
Caddy真的是王道，什么泛域名，一个端口跑3个协议，都可以
用到Caddy，就要解决后端Nginx ingress无法获得客户真实IP的问题
Caddy配置如下：
General Settings：
Enable Layer4 Proxy 要勾选上
Auto HTTPS 要选中Off
其它保持默认，然后去到Layer4 Proxy进行配置，同样要配2个，一个HTTP，一个TLS
编辑HTTP的代理，注意 Domain 的地方需要把用到的所有域名列进去
编译TLS的代理
注意上面，Proxy Protocol都要选中v2，这样客户端真实IP才可以透传给后端的Nginx ingress
那同样后端的Nginx ingress的configmap，也需要加上Proxy Protocol的部分
我们用的是官网的 ingress-nginx，配置文件是 ingress-nginx 的namespace中
configmap ingress-nginx-controller，内容如下
apiVersion: v1 data: use-proxy-protocol: "true" kind: ConfigMap metadata: annotations: meta.helm.sh/release-name: ingress-nginx meta.helm.sh/release-namespace: ingress-nginx nginx.ingress.kubernetes.io/configuration-snippet: "true" nginx.ingress.kubernetes.io/location-snippet: "true" nginx.ingress.kubernetes.io/server-snippet: "true" creationTimestamp: "2025-08-27T07:38:49Z" labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.13.1 helm.sh/chart: ingress-nginx-4.13.1 name: ingress-nginx-controller namespace: ingress-nginx resourceVersion: "22298827" uid: d6eeef3c-7e44-4667-854a-c7693006b221 编辑后，nginx ingress会自动reload
...</p></div><footer class=entry-footer><span title='2025-10-14 09:05:11 +0800 CST'>2025年14月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>88 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- caddy篇" href=https://rendoumi.com/posts/20251014-opnsense_caddy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- relayd篇
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>新托管了一个机房服务器，基本全用开源软件来构建：
那Firewall就用的OPNsense，后端自建Kubernetes，那OPNsense需要当作一个LoadBalance来使用
结构图如下，证书是放在了Nginx ingres上：
那方法有很多，各有利弊，先说第一个，relayd的做法
relayd是最早的OPNsense的插件，用来做负载均衡，安装这个plugin插件
配置如下：
General Settings：
由于虚机的cpu是4个，所以进程设置成4
Backend Hosts:
后端节点有4个，只写IP即可
Table Checks：
端口检查，因为是直通，所以就设置成TCP检查即可
Tables：
Hosts选中4个节点
Virtual Server：
80和443各有一个
每个呢，设置好前面的监听地址和端口，后端的Table 服务器和Table check的协议，就ok了
最后去 General Settings 选中 Enable Relayd，然后save，就可以了
这么多贴图，是因为如果从CLI配置，其实就一个很简单的relayd.conf文本文件
但是从GUI，就一大堆，而且生成的东西简直不知所云
这样做relayd就相当于一个直通的LoadBalance，把流量送入后端的Nginx ingress所开的NodePort。
这样就可用了。
这样有个弊端，Nginx的ingress拿不到客户端的真实IP，X-forwarded-for无法传过来真的客户端IP，网上查文档是可以的，但是从GUI配了半天，也不知道怎么配，服了也是。</p></div><footer class=entry-footer><span title='2025-10-14 09:01:11 +0800 CST'>2025年14月</span>&nbsp;·&nbsp;<span>1 分钟</span>&nbsp;·&nbsp;<span>36 字</span>&nbsp;·&nbsp;<span>八戒</span></footer><a class=entry-link aria-label="post link to OPNsense如何做LoadBalance接入后端的Kubernetes nginx ingress --- relayd篇" href=https://rendoumi.com/posts/20251014-opnsense_relayd/></a></article><div class=pagination><ul class=pagination-list><li class="page-item first"><a class=page-link href=/posts/ aria-label="First Page"><span aria-hidden=true>&#9668;</span></a></li><li class="page-item prev"><a class=page-link href=/posts/page/3/ aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a class=page-link href=/posts/>1</a></li><li class=page-item><a class=page-link href=/posts/page/2/>2</a></li><li class=page-item><a class=page-link href=/posts/page/3/>3</a></li><li class="page-item active"><span class=page-link aria-current=page>4</span></li><li class=page-item><a class=page-link href=/posts/page/5/>5</a></li><li class=page-item><a class=page-link href=/posts/page/6/>6</a></li><li class=page-item><a class=page-link href=/posts/page/7/>7</a></li><li class=page-item><a class=page-link href=/posts/page/8/>8</a></li><li class="page-item next"><a class=page-link href=/posts/page/5/ aria-label=Next><span aria-hidden=true>&#187;</span></a></li><li class="page-item last"><a class=page-link href=/posts/page/37/ aria-label="Last Page"><span aria-hidden=true>&#9658;</span></a></li></ul><div class=total-pages>共 37 页</div></div></main><footer class=footer><span>Copyright © 2020-2025 Zhang Ranrui. All Rights Reserved.</span><br>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>